<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Carta â€” Terrain Wavetable Synth</title>
        <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        />
        <style>
            /* ============================================================
           CSS RESET & VARIABLES
           ============================================================ */
            *,
            *::before,
            *::after {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            :root {
                --bg: #000000;
                --surface: #0a0a0a;
                --border: #222222;
                --text: #ffffff;
                --text-muted: #666666;
                --accent: #ffffff;
                --font-mono:
                    "SF Mono", "Monaco", "Inconsolata", "Fira Code", monospace;
            }

            /* Light mode */
            .light-mode {
                --bg: #ffffff;
                --surface: #f5f5f5;
                --border: #dddddd;
                --text: #000000;
                --text-muted: #888888;
                --accent: #000000;
                background: var(--bg);
            }

            /* ============================================================
           BASE STYLES
           ============================================================ */
            html,
            body {
                height: 100%;
                background: var(--bg);
                color: var(--text);
                font-family: var(--font-mono);
                font-size: 12px;
                line-height: 1.4;
                transition:
                    background 0.2s,
                    color 0.2s;
            }

            /* ============================================================
           APP LAYOUT
           ============================================================ */
            #app {
                display: flex;
                flex-direction: column;
                min-height: 100vh;
                max-width: 1400px;
                margin: 0 auto;
                padding: 16px;
                gap: 6px;
                background: var(--bg);
            }

            main {
                flex: 0 0 auto;
                height: 400px;
            }

            /* ============================================================
           HEADER
           ============================================================ */
            header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding-bottom: 12px;
                border-bottom: 1px solid var(--border);
            }

            h1 {
                font-size: 14px;
                font-weight: 400;
                letter-spacing: 0.2em;
                text-transform: uppercase;
            }

            .header-controls {
                display: flex;
                align-items: center;
                gap: 16px;
            }

            .control-group {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .control-group label {
                color: var(--text-muted);
                font-size: 10px;
                text-transform: uppercase;
                letter-spacing: 0.1em;
            }

            /* Theme toggle button */
            .theme-toggle {
                background: none;
                border: 1px solid var(--border);
                color: var(--text);
                padding: 4px 8px;
                font-family: inherit;
                font-size: 10px;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                transition: border-color 0.2s;
            }

            .theme-toggle:hover {
                border-color: var(--text);
            }

            /* ============================================================
           MAIN CONTENT AREA
           ============================================================ */
            main {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 12px;
                min-height: 0;
            }

            /* ============================================================
           MAP SECTION
           ============================================================ */
            #map-section {
                background: var(--surface);
                border: 1px solid var(--border);
                position: relative;
                min-height: 300px;
                display: flex;
                flex-direction: column;
            }

            /* Search bar */
            .map-search {
                display: flex;
                gap: 8px;
                padding: 8px;
                background: var(--bg);
                border-bottom: 1px solid var(--border);
            }

            .map-search input {
                flex: 1;
                background: var(--surface);
                border: 1px solid var(--border);
                color: var(--text);
                padding: 6px 10px;
                font-family: inherit;
                font-size: 11px;
                height: 32px;
            }

            .map-search input::placeholder {
                color: var(--text-muted);
            }

            .map-search input:focus {
                outline: none;
                border-color: var(--text-muted);
            }

            .map-search button {
                background: var(--surface);
                border: 1px solid var(--border);
                color: var(--text);
                padding: 6px 12px;
                font-family: inherit;
                font-size: 10px;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 0.05em;
                height: 32px;
            }

            .map-search button:hover {
                border-color: var(--text);
            }

            .map-search .location-btn {
                padding: 6px 8px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .map-search .location-btn svg {
                width: 14px;
                height: 14px;
            }

            .map-search .location-btn.locating {
                animation: pulse 1s ease-in-out infinite;
            }

            @keyframes pulse {
                0%,
                100% {
                    opacity: 1;
                }
                50% {
                    opacity: 0.5;
                }
            }

            #map {
                flex: 1;
                min-height: 0;
            }

            /* Override Leaflet styles for dark theme */
            .leaflet-container {
                background: var(--bg);
            }

            .leaflet-tile-pane {
                filter: grayscale(100%) invert(100%) contrast(0.9);
            }

            .light-mode .leaflet-tile-pane {
                filter: grayscale(100%) contrast(1.1);
            }

            .map-info {
                position: absolute;
                bottom: 8px;
                left: 8px;
                z-index: 1000;
                background: rgba(0, 0, 0, 0.8);
                padding: 6px 10px;
                font-size: 10px;
                color: var(--text-muted);
                border: 1px solid var(--border);
            }

            .light-mode .map-info {
                background: rgba(255, 255, 255, 0.9);
            }

            /* ============================================================
           VISUALIZATION SECTION
           ============================================================ */
            #visualization {
                position: relative;
                min-height: 0;
            }

            .viz-panel {
                background: var(--surface);
                border: 1px solid var(--border);
                position: relative;
                overflow: hidden;
            }

            .viz-panel canvas {
                width: 100%;
                height: 100%;
                display: block;
            }

            /* Terrain panel fills the entire visualization area */
            #terrain-panel {
                position: absolute;
                inset: 0;
            }

            /* Terrain empty state */
            .terrain-empty {
                position: absolute;
                inset: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 5;
                pointer-events: none;
            }

            .terrain-empty span {
                color: var(--text-muted);
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.1em;
            }

            .terrain-empty.hidden {
                display: none;
            }

            /* Waveform panel inset in bottom-right corner */
            #waveform-panel {
                position: absolute;
                bottom: 12px;
                right: 12px;
                width: 150px;
                height: 80px;
                z-index: 10;
                background: rgba(10, 10, 10, 0.85);
                border: 1px solid var(--border);
            }

            .light-mode #waveform-panel {
                background: rgba(245, 245, 245, 0.9);
            }

            .viz-label {
                position: absolute;
                top: 8px;
                left: 8px;
                font-size: 10px;
                color: var(--text-muted);
                text-transform: uppercase;
                letter-spacing: 0.1em;
                z-index: 10;
                pointer-events: none;
            }

            /* 3D terrain controls */
            .terrain-controls {
                position: absolute;
                top: 8px;
                right: 8px;
                display: flex;
                gap: 4px;
                z-index: 10;
            }

            .terrain-controls button {
                background: var(--bg);
                border: 1px solid var(--border);
                color: var(--text-muted);
                width: 24px;
                height: 24px;
                font-size: 12px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .terrain-controls button:hover {
                color: var(--text);
                border-color: var(--text);
            }

            .terrain-intensity {
                display: flex;
                align-items: center;
                gap: 6px;
                background: var(--bg);
                border: 1px solid var(--border);
                padding: 4px 8px;
                font-size: 9px;
                color: var(--text-muted);
            }

            .terrain-intensity label {
                text-transform: uppercase;
                letter-spacing: 0.05em;
                white-space: nowrap;
            }

            .terrain-intensity input[type="range"] {
                width: 60px;
                height: 3px;
            }

            .terrain-intensity .intensity-value {
                min-width: 28px;
                text-align: right;
            }

            /* Position tooltip below for elements near top edge (avoid overflow clipping) */
            .terrain-controls [data-tooltip]::after {
                bottom: auto;
                top: 100%;
                margin-bottom: 0;
                margin-top: 6px;
            }

            /* ============================================================
           CONTROLS SECTION
           ============================================================ */
            #controls {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            /* ============================================================
               PARAM ROW (Morph, Filter, ADSR)
               ============================================================ */
            .param-row {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 8px 12px;
                background: var(--surface);
                border: 1px solid var(--border);
            }

            .param-row .row-label {
                font-size: 10px;
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                color: var(--text);
                min-width: 50px;
            }

            .param-row .main-slider {
                flex: 1;
                min-width: 100px;
            }

            .param-row .param-value {
                font-size: 10px;
                color: var(--text-muted);
                min-width: 45px;
                text-align: right;
                font-family: "JetBrains Mono", monospace;
            }

            .param-row .mod-select {
                font-size: 10px;
                min-width: 80px;
            }

            .param-row .mini-param {
                display: flex;
                align-items: center;
                gap: 4px;
            }

            .param-row .mini-param label {
                font-size: 9px;
                text-transform: uppercase;
                color: var(--text-muted);
            }

            .param-row .mini-param input[type="range"] {
                width: 50px;
            }

            .param-row .mini-value {
                font-size: 9px;
                color: var(--text-muted);
                min-width: 28px;
                font-family: "JetBrains Mono", monospace;
            }

            .param-row .row-divider {
                width: 1px;
                height: 20px;
                background: var(--border);
                margin: 0 4px;
            }

            /* ============================================================
               THREE COLUMN SECTION
               ============================================================ */
            #three-columns {
                display: grid;
                grid-template-columns: 1fr 1.5fr 1fr;
                gap: 1px;
                background: var(--border);
                border: 1px solid var(--border);
            }

            .column {
                background: var(--surface);
                padding: 8px 12px;
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .column-header {
                font-size: 10px;
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                color: var(--text);
                height: 18px;
                padding-bottom: 4px;
                border-bottom: 1px solid var(--border);
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
            }

            .column-param {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .column-param label {
                font-size: 9px;
                text-transform: uppercase;
                letter-spacing: 0.05em;
                color: var(--text-muted);
                min-width: 45px;
            }

            .column-param input[type="range"] {
                flex: 1;
                min-width: 50px;
            }

            .column-param .param-value {
                font-size: 9px;
                color: var(--text-muted);
                min-width: 35px;
                text-align: right;
                font-family: "JetBrains Mono", monospace;
            }

            .column-param select {
                font-size: 10px;
            }

            .column-subheader {
                font-size: 9px;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                color: var(--text-muted);
                margin-top: 6px;
            }

            .column-param .range-dash {
                font-size: 10px;
                color: var(--text-muted);
            }

            /* Dual-range slider for octave selection */
            .dual-range-slider {
                position: relative;
                width: 80px;
                height: 20px;
            }

            .dual-range-slider input[type="range"] {
                position: absolute;
                width: 100%;
                pointer-events: none;
                -webkit-appearance: none;
                appearance: none;
                background: transparent;
                height: 20px;
            }

            .dual-range-slider input[type="range"]::-webkit-slider-thumb {
                pointer-events: all;
                -webkit-appearance: none;
                appearance: none;
                width: 12px;
                height: 12px;
                background: var(--text);
                border-radius: 50%;
                cursor: pointer;
                position: relative;
                z-index: 2;
            }

            .dual-range-slider input[type="range"]::-moz-range-thumb {
                pointer-events: all;
                width: 12px;
                height: 12px;
                background: var(--text);
                border-radius: 50%;
                border: none;
                cursor: pointer;
                position: relative;
                z-index: 2;
            }

            .dual-range-slider .range-track {
                position: absolute;
                top: 50%;
                left: 0;
                right: 0;
                height: 2px;
                background: var(--border);
                transform: translateY(-50%);
                z-index: 0;
            }

            .dual-range-slider .range-selected {
                position: absolute;
                top: 50%;
                height: 2px;
                background: var(--text);
                transform: translateY(-50%);
                z-index: 1;
            }

            /* Play button */
            .play-btn {
                background: none;
                border: 1px solid var(--border);
                color: var(--text);
                width: 20px;
                height: 20px;
                padding: 3px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 2px;
            }

            .play-btn:hover {
                border-color: var(--text);
            }

            .play-btn.playing {
                background: var(--text);
                color: var(--bg);
            }

            .play-btn svg {
                width: 10px;
                height: 10px;
            }

            /* ============================================================
           RANGE INPUT STYLING
           ============================================================ */
            input[type="range"] {
                -webkit-appearance: none;
                appearance: none;
                background: transparent;
                cursor: pointer;
                height: 20px;
            }

            input[type="range"]::-webkit-slider-runnable-track {
                height: 2px;
                background: var(--border);
            }

            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 12px;
                height: 12px;
                background: var(--text);
                border-radius: 50%;
                margin-top: -5px;
            }

            input[type="range"]::-moz-range-track {
                height: 2px;
                background: var(--border);
            }

            input[type="range"]::-moz-range-thumb {
                width: 12px;
                height: 12px;
                background: var(--text);
                border: none;
                border-radius: 50%;
            }

            /* ============================================================
           CUSTOM DROPDOWN STYLING
           ============================================================ */
            .custom-select {
                position: relative;
                display: inline-block;
            }

            .custom-select-trigger {
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
                background-color: var(--bg);
                border: 1px solid var(--border);
                color: var(--text);
                padding: 6px 8px;
                font-family: var(--font-mono);
                font-size: 10px;
                cursor: pointer;
                min-width: 80px;
                height: 32px;
                user-select: none;
            }

            .custom-select-trigger:hover {
                border-color: var(--text-muted);
            }

            .custom-select.open .custom-select-trigger {
                border-color: var(--text);
            }

            .custom-select-arrow {
                width: 8px;
                height: 8px;
                flex-shrink: 0;
            }

            .custom-select-arrow svg {
                display: block;
                width: 100%;
                height: 100%;
                fill: var(--text-muted);
            }

            .custom-select.open .custom-select-arrow svg {
                transform: rotate(180deg);
            }

            .custom-select-options {
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                margin-top: 2px;
                background: var(--bg);
                border: 1px solid var(--border);
                max-height: 200px;
                overflow-y: auto;
                z-index: 1000;
                display: none;
            }

            .custom-select.open .custom-select-options {
                display: block;
            }

            .custom-select-option {
                padding: 6px 8px;
                font-size: 10px;
                cursor: pointer;
                color: var(--text);
            }

            .custom-select-option:hover {
                background: var(--border);
            }

            .custom-select-option.selected {
                background: var(--border);
            }

            /* Hide native select when using custom */
            .custom-select select {
                position: absolute;
                opacity: 0;
                pointer-events: none;
            }

            /* ============================================================
           CSS TOOLTIPS
           ============================================================ */
            [data-tooltip] {
                position: relative;
            }

            [data-tooltip]::after {
                content: attr(data-tooltip);
                position: absolute;
                bottom: 100%;
                left: 50%;
                transform: translateX(-50%);
                margin-bottom: 6px;
                padding: 4px 8px;
                background: var(--text);
                color: var(--bg);
                font-size: 10px;
                white-space: nowrap;
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.15s;
                z-index: 1001;
            }

            [data-tooltip]:hover::after {
                opacity: 1;
            }

            /* ============================================================
           STATUS BAR
           ============================================================ */
            #status {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 6px 12px;
                background: var(--surface);
                border: 1px solid var(--border);
                font-size: 10px;
                color: var(--text-muted);
            }

            #status .midi-status {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .midi-indicator {
                width: 6px;
                height: 6px;
                border-radius: 50%;
                background: var(--text-muted);
            }

            .midi-indicator.connected {
                background: #00cc00;
            }

            .light-mode .midi-indicator.connected {
                background: #009900;
            }

            .keyboard-hint {
                font-family: "JetBrains Mono", monospace;
                font-size: 9px;
                color: var(--text-muted);
                letter-spacing: 0.5px;
            }

            /* ============================================================
           LOADING STATE
           ============================================================ */
            .loading-overlay {
                position: absolute;
                inset: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 2000;
            }

            .light-mode .loading-overlay {
                background: rgba(255, 255, 255, 0.8);
            }

            .loading-overlay.hidden {
                display: none;
            }

            .spinner {
                width: 24px;
                height: 24px;
                border: 2px solid var(--border);
                border-top-color: var(--text);
                border-radius: 50%;
                animation: spin 0.8s linear infinite;
            }

            @keyframes spin {
                to {
                    transform: rotate(360deg);
                }
            }

            /* ============================================================
           UTILITY CLASSES
           ============================================================ */
            .hidden {
                display: none !important;
            }
        </style>
    </head>
    <body>
        <div id="app">
            <!-- Header -->
            <header>
                <h1>Carta</h1>
                <div class="header-controls">
                    <div class="control-group">
                        <label for="master-volume">Vol</label>
                        <input
                            type="range"
                            id="master-volume"
                            min="0"
                            max="1"
                            step="0.01"
                            value="0.7"
                            data-tooltip="Master volume"
                        />
                    </div>
                    <button class="theme-toggle" id="theme-toggle" data-tooltip="Toggle theme">
                        Light
                    </button>
                </div>
            </header>

            <!-- Main content: Map + Visualizations -->
            <main>
                <section id="map-section">
                    <div class="map-search">
                        <input
                            type="text"
                            id="search-input"
                            placeholder="Search location or coords (lat, lng)"
                        />
                        <select
                            id="area-size"
                            data-tooltip="Terrain sample area"
                        >
                            <option value="5">5km</option>
                            <option value="10" selected>10km</option>
                            <option value="50">50km</option>
                        </select>
                        <button id="search-btn" data-tooltip="Search location">Go</button>
                        <button
                            id="location-btn"
                            class="location-btn"
                            data-tooltip="My location"
                        >
                            <svg
                                viewBox="0 0 24 24"
                                fill="none"
                                stroke="currentColor"
                                stroke-width="2"
                                stroke-linecap="round"
                                stroke-linejoin="round"
                            >
                                <circle cx="12" cy="12" r="3" />
                                <path d="M12 2v4M12 18v4M2 12h4M18 12h4" />
                            </svg>
                        </button>
                    </div>
                    <div id="map"></div>
                    <div class="map-info">
                        <span id="location-display"
                            >Click map to select terrain</span
                        >
                    </div>
                    <div id="map-loading" class="loading-overlay hidden">
                        <div class="spinner"></div>
                    </div>
                </section>

                <section id="visualization">
                    <div class="viz-panel" id="terrain-panel">
                        <span class="viz-label">Terrain</span>
                        <div class="terrain-empty" id="terrain-empty">
                            <span>Click map to load terrain</span>
                        </div>
                        <canvas id="terrain-canvas"></canvas>
                        <div class="terrain-controls">
                            <div class="terrain-intensity">
                                <label>Intensity</label>
                                <input
                                    type="range"
                                    id="terrain-intensity"
                                    min="0"
                                    max="100"
                                    step="1"
                                    value="100"
                                    data-tooltip="Blend between flat and full terrain waveform"
                                />
                                <span
                                    class="intensity-value"
                                    id="terrain-intensity-value"
                                    >100%</span
                                >
                            </div>
                            <button id="reset-view" data-tooltip="Reset view">
                                <svg
                                    width="14"
                                    height="14"
                                    viewBox="0 0 24 24"
                                    fill="none"
                                    stroke="currentColor"
                                    stroke-width="2"
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                >
                                    <path
                                        d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
                                    />
                                    <path d="M3 3v5h5" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="viz-panel" id="waveform-panel">
                        <span class="viz-label">Waveform</span>
                        <canvas id="waveform-canvas"></canvas>
                    </div>
                </section>
            </main>
            <!-- Morph Row -->
            <div class="param-row" id="morph-row">
                <label class="row-label">Morph</label>
                <input
                    type="range"
                    id="morph-slider"
                    class="main-slider"
                    min="0"
                    max="1"
                    step="0.001"
                    value="0.5"
                    data-tooltip="Wavetable position"
                />
                <span class="param-value" id="morph-value">0.50</span>
                <div class="row-divider"></div>
                <select id="morph-mod-source" class="mod-select" data-tooltip="Modulation source">
                    <option value="manual">Manual</option>
                    <option value="lfo1">LFO 1</option>
                    <option value="lfo2">LFO 2</option>
                    <option value="snh">S&H</option>
                    <option value="drift">Drift</option>
                    <option value="midi-wheel">Mod Wheel</option>
                    <option value="midi-velocity">Velocity</option>
                </select>
                <div class="mini-param">
                    <label>Rng</label>
                    <input
                        type="range"
                        id="morph-mod-range"
                        min="0.01"
                        max="1"
                        step="0.01"
                        value="1"
                        data-tooltip="Modulation Range"
                    />
                </div>
                <div class="mini-param">
                    <label>Ofs</label>
                    <input
                        type="range"
                        id="morph-mod-offset"
                        min="0"
                        max="1"
                        step="0.01"
                        value="0"
                        data-tooltip="Modulation Offset"
                    />
                </div>
            </div>

            <!-- Filter Row -->
            <div class="param-row" id="filter-row">
                <label class="row-label">Filter</label>
                <input
                    type="range"
                    id="filter-cutoff"
                    class="main-slider"
                    min="20"
                    max="20000"
                    step="1"
                    value="20000"
                    data-tooltip="Cutoff frequency"
                />
                <span class="param-value" id="filter-cutoff-value">20kHz</span>
                <div class="mini-param">
                    <label>Res</label>
                    <input
                        type="range"
                        id="filter-resonance"
                        min="0"
                        max="20"
                        step="0.1"
                        value="0"
                        data-tooltip="Resonance"
                    />
                    <span class="mini-value" id="filter-resonance-value"
                        >0.0</span
                    >
                </div>
                <div class="row-divider"></div>
                <select id="filter-mod-source" class="mod-select" data-tooltip="Modulation source">
                    <option value="manual">Off</option>
                    <option value="lfo1">LFO 1</option>
                    <option value="lfo2">LFO 2</option>
                    <option value="snh">S&H</option>
                    <option value="drift">Drift</option>
                    <option value="midi-wheel">Mod Wheel</option>
                    <option value="midi-velocity">Velocity</option>
                </select>
                <div class="mini-param">
                    <label>Rng</label>
                    <input
                        type="range"
                        id="filter-mod-range"
                        min="0.01"
                        max="1"
                        step="0.01"
                        value="0.5"
                        data-tooltip="Modulation Range"
                    />
                </div>
                <div class="mini-param">
                    <label>Ofs</label>
                    <input
                        type="range"
                        id="filter-mod-offset"
                        min="0"
                        max="1"
                        step="0.01"
                        value="0"
                        data-tooltip="Modulation Offset"
                    />
                </div>
            </div>

            <!-- Three Column Section -->
            <div id="three-columns">
                <!-- Modulation Column -->
                <div class="column" id="mod-column">
                    <div class="column-header">Modulation</div>
                    <div class="column-param">
                        <label>LFO 1</label>
                        <input
                            type="range"
                            id="lfo1-rate"
                            min="0"
                            max="1"
                            step="0.01"
                            value="0.43"
                            data-tooltip="LFO 1 Rate (Hz)"
                        />
                        <span class="param-value" id="lfo1-rate-value"
                            >1.0</span
                        >
                    </div>
                    <div class="column-param">
                        <label>LFO 2</label>
                        <input
                            type="range"
                            id="lfo2-rate"
                            min="0"
                            max="1"
                            step="0.01"
                            value="0.43"
                            data-tooltip="LFO 2 Rate (Hz)"
                        />
                        <span class="param-value" id="lfo2-rate-value"
                            >1.0</span
                        >
                    </div>
                    <div class="column-subheader">Envelope</div>
                    <div class="column-param">
                        <label>A</label>
                        <input
                            type="range"
                            id="attack"
                            min="0.001"
                            max="2"
                            step="0.001"
                            value="0.01"
                            data-tooltip="Attack"
                        />
                        <span class="param-value" id="attack-value">0.01</span>
                    </div>
                    <div class="column-param">
                        <label>D</label>
                        <input
                            type="range"
                            id="decay"
                            min="0.001"
                            max="2"
                            step="0.001"
                            value="0.1"
                            data-tooltip="Decay"
                        />
                        <span class="param-value" id="decay-value">0.10</span>
                    </div>
                    <div class="column-param">
                        <label>S</label>
                        <input
                            type="range"
                            id="sustain"
                            min="0"
                            max="1"
                            step="0.01"
                            value="0.7"
                            data-tooltip="Sustain"
                        />
                        <span class="param-value" id="sustain-value">0.70</span>
                    </div>
                    <div class="column-param">
                        <label>R</label>
                        <input
                            type="range"
                            id="release"
                            min="0.001"
                            max="3"
                            step="0.001"
                            value="0.3"
                            data-tooltip="Release"
                        />
                        <span class="param-value" id="release-value">0.30</span>
                    </div>
                </div>

                <!-- Sequencer Column -->
                <div class="column" id="seq-column">
                    <div class="column-header">
                        <span>Sequencer</span>
                        <button
                            id="gen-play-btn"
                            class="play-btn"
                            data-tooltip="Play/Pause"
                        >
                            <svg
                                id="gen-play-icon"
                                viewBox="0 0 24 24"
                                fill="currentColor"
                            >
                                <polygon points="5,3 19,12 5,21" />
                            </svg>
                        </button>
                    </div>
                    <div class="column-param">
                        <label>Root</label>
                        <select id="root-note" data-tooltip="Root note">
                            <option value="C">C</option>
                            <option value="C#">C#</option>
                            <option value="D">D</option>
                            <option value="D#">D#</option>
                            <option value="E">E</option>
                            <option value="F">F</option>
                            <option value="F#">F#</option>
                            <option value="G">G</option>
                            <option value="G#">G#</option>
                            <option value="A">A</option>
                            <option value="A#">A#</option>
                            <option value="B">B</option>
                        </select>
                        <label>Scale</label>
                        <select id="scale-type" data-tooltip="Musical scale">
                            <option value="chromatic">Chromatic</option>
                            <option value="major">Major</option>
                            <option value="minor">Minor</option>
                            <option value="dorian">Dorian</option>
                            <option value="phrygian">Phrygian</option>
                            <option value="lydian">Lydian</option>
                            <option value="mixolydian">Mixolydian</option>
                            <option value="pentatonic">Pentatonic</option>
                            <option value="blues">Blues</option>
                        </select>
                    </div>
                    <div class="column-param">
                        <label>BPM</label>
                        <input
                            type="range"
                            id="gen-bpm"
                            min="30"
                            max="240"
                            step="1"
                            value="120"
                            data-tooltip="Tempo"
                        />
                        <span class="param-value" id="gen-bpm-value">120</span>
                    </div>
                    <div class="column-param">
                        <label>Prob</label>
                        <input
                            type="range"
                            id="gen-probability"
                            min="0"
                            max="1"
                            step="0.01"
                            value="0.7"
                            data-tooltip="Note trigger probability"
                        />
                        <span class="param-value" id="gen-probability-value"
                            >70%</span
                        >
                    </div>
                    <div class="column-param">
                        <label>Octave</label>
                        <div class="dual-range-slider" id="octave-range" data-tooltip="Octave range">
                            <input
                                type="range"
                                id="gen-octave-low"
                                min="2"
                                max="6"
                                value="4"
                                step="1"
                            />
                            <input
                                type="range"
                                id="gen-octave-high"
                                min="2"
                                max="6"
                                value="5"
                                step="1"
                            />
                            <div class="range-track"></div>
                            <div class="range-selected"></div>
                        </div>
                        <span class="param-value" id="octave-range-value"
                            >4-5</span
                        >
                    </div>
                    <div class="column-param">
                        <label>Length</label>
                        <select id="gen-length" data-tooltip="Note length">
                            <option value="0.25">1/16</option>
                            <option value="0.5">1/8</option>
                            <option value="1" selected>1/4</option>
                            <option value="2">1/2</option>
                            <option value="4">1</option>
                        </select>
                        <label>Pattern</label>
                        <select id="gen-pattern" data-tooltip="Sequence pattern">
                            <option value="random">Rnd</option>
                            <option value="ascending">Up</option>
                            <option value="descending">Dn</option>
                            <option value="pendulum">Pnd</option>
                        </select>
                    </div>
                </div>

                <!-- Reverb Column -->
                <div class="column" id="reverb-column">
                    <div class="column-header">Reverb</div>
                    <div class="column-param">
                        <label>Mix</label>
                        <input
                            type="range"
                            id="reverb-mix"
                            min="0"
                            max="1"
                            step="0.01"
                            value="0"
                            data-tooltip="Wet/dry mix"
                        />
                        <span class="param-value" id="reverb-mix-value"
                            >0%</span
                        >
                    </div>
                    <div class="column-param">
                        <label>Size</label>
                        <input
                            type="range"
                            id="reverb-size"
                            min="0"
                            max="1"
                            step="0.01"
                            value="0.5"
                            data-tooltip="Room Size"
                        />
                        <span class="param-value" id="reverb-size-value"
                            >50%</span
                        >
                    </div>
                    <div class="column-param">
                        <label>Decay</label>
                        <input
                            type="range"
                            id="reverb-decay"
                            min="0.1"
                            max="5"
                            step="0.1"
                            value="2"
                            data-tooltip="Decay time"
                        />
                        <span class="param-value" id="reverb-decay-value"
                            >2.0s</span
                        >
                    </div>
                    <div class="column-param">
                        <label>Pre-dly</label>
                        <input
                            type="range"
                            id="reverb-predelay"
                            min="0"
                            max="100"
                            step="1"
                            value="10"
                            data-tooltip="Pre-delay (ms)"
                        />
                        <span class="param-value" id="reverb-predelay-value"
                            >10ms</span
                        >
                    </div>
                    <div class="column-param">
                        <label>Damp</label>
                        <input
                            type="range"
                            id="reverb-damping"
                            min="0"
                            max="1"
                            step="0.01"
                            value="0.4"
                            data-tooltip="High Frequency Damping"
                        />
                        <span class="param-value" id="reverb-damping-value"
                            >40%</span
                        >
                    </div>
                    <div class="column-param">
                        <label>Shimmer</label>
                        <input
                            type="range"
                            id="reverb-shimmer"
                            min="0"
                            max="1"
                            step="0.01"
                            value="0"
                            data-tooltip="Pitch-shifted feedback"
                        />
                        <span class="param-value" id="reverb-shimmer-value"
                            >0%</span
                        >
                    </div>
                </div>
            </div>

            <!-- Status bar -->
            <footer id="status">
                <span id="status-message">Click map to load terrain</span>
                <span class="keyboard-hint">Keys A-L to play</span>
                <div class="midi-status">
                    <span class="midi-indicator" id="midi-indicator"></span>
                    <span id="midi-status">No MIDI</span>
                </div>
            </footer>
        </div>

        <!-- External libraries -->
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

        <script>
            // OrbitControls inline (since CDN version has module issues)
            // Simplified orbit controls for terrain viewing
            THREE.OrbitControls = function (camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.enabled = true;
                this.enableDamping = false;
                this.dampingFactor = 0.05;
                this.enablePan = false;
                this.minDistance = 1;
                this.maxDistance = 5;

                let spherical = {
                    radius: 3,
                    phi: Math.PI / 4,
                    theta: Math.PI / 4,
                };
                let sphericalDelta = { phi: 0, theta: 0 };
                let scale = 1;
                let isDragging = false;
                let previousMouse = { x: 0, y: 0 };

                const updateCamera = () => {
                    const r = spherical.radius;
                    camera.position.x =
                        r * Math.sin(spherical.phi) * Math.cos(spherical.theta);
                    camera.position.y = r * Math.cos(spherical.phi);
                    camera.position.z =
                        r * Math.sin(spherical.phi) * Math.sin(spherical.theta);
                    camera.lookAt(0, 0, 0);
                };

                const onMouseDown = (e) => {
                    if (!this.enabled) return;
                    isDragging = true;
                    previousMouse.x = e.clientX;
                    previousMouse.y = e.clientY;
                };

                const onMouseMove = (e) => {
                    if (!isDragging || !this.enabled) return;
                    const deltaX = e.clientX - previousMouse.x;
                    const deltaY = e.clientY - previousMouse.y;
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi = Math.max(
                        0.1,
                        Math.min(Math.PI - 0.1, spherical.phi + deltaY * 0.01),
                    );
                    previousMouse.x = e.clientX;
                    previousMouse.y = e.clientY;
                };

                const onMouseUp = () => {
                    isDragging = false;
                };

                const onWheel = (e) => {
                    if (!this.enabled) return;
                    e.preventDefault();
                    spherical.radius = Math.max(
                        this.minDistance,
                        Math.min(
                            this.maxDistance,
                            spherical.radius + e.deltaY * 0.002,
                        ),
                    );
                };

                domElement.addEventListener("mousedown", onMouseDown);
                domElement.addEventListener("mousemove", onMouseMove);
                domElement.addEventListener("mouseup", onMouseUp);
                domElement.addEventListener("mouseleave", onMouseUp);
                domElement.addEventListener("wheel", onWheel, {
                    passive: false,
                });

                // Touch support
                domElement.addEventListener("touchstart", (e) => {
                    if (e.touches.length === 1) {
                        isDragging = true;
                        previousMouse.x = e.touches[0].clientX;
                        previousMouse.y = e.touches[0].clientY;
                    }
                });
                domElement.addEventListener("touchmove", (e) => {
                    if (!isDragging || e.touches.length !== 1) return;
                    const deltaX = e.touches[0].clientX - previousMouse.x;
                    const deltaY = e.touches[0].clientY - previousMouse.y;
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi = Math.max(
                        0.1,
                        Math.min(Math.PI - 0.1, spherical.phi + deltaY * 0.01),
                    );
                    previousMouse.x = e.touches[0].clientX;
                    previousMouse.y = e.touches[0].clientY;
                });
                domElement.addEventListener("touchend", () => {
                    isDragging = false;
                });

                this.update = () => {
                    updateCamera();
                };
                this.reset = () => {
                    spherical = {
                        radius: 3,
                        phi: Math.PI / 4,
                        theta: Math.PI / 4,
                    };
                    updateCamera();
                };

                updateCamera();
            };
        </script>

        <script>
            // ============================================================
            // CONFIGURATION
            // ============================================================
            const CONFIG = {
                wavetable: {
                    samplesPerWaveform: 256,
                    numberOfFrames: 32,
                    gridSizeKm: 10.0, // 10kmÂ² for more terrain variation
                },
                audio: {
                    polyphony: 8,
                },
                api: {
                    // CORS proxy - leave empty when deployed, use "https://corsproxy.io/?" for local file://
                    corsProxy: "",
                    primary: "https://api.open-elevation.com/api/v1/lookup",
                    fallback: "https://api.opentopodata.org/v1/srtm30m",
                    maxLocationsPerRequest: 1000, // ~9 requests for 8192 points
                    delayBetweenChunks: 100,
                },
                map: {
                    defaultCenter: [46.8182, 8.2275], // Swiss Alps
                    defaultZoom: 6,
                },
            };

            // ============================================================
            // TERRAIN DATA SERVICE
            // ============================================================
            class TerrainService {
                constructor() {
                    this.cache = new Map();
                }

                /**
                 * Generate cache key from coordinates.
                 */
                getCacheKey(lat, lng) {
                    return `${lat.toFixed(4)},${lng.toFixed(4)},${CONFIG.wavetable.gridSizeKm}km`;
                }

                /**
                 * Generate grid of coordinates for elevation sampling.
                 */
                generateGridLocations(centerLat, centerLng, config) {
                    const locations = [];
                    const { samplesPerWaveform, numberOfFrames, gridSizeKm } =
                        config;

                    const latOffset = gridSizeKm / 2 / 111.0;
                    const lngOffset =
                        gridSizeKm /
                        2 /
                        (111.0 * Math.cos((centerLat * Math.PI) / 180));

                    const latStep = (2 * latOffset) / (numberOfFrames - 1);
                    const lngStep = (2 * lngOffset) / (samplesPerWaveform - 1);

                    for (let frame = 0; frame < numberOfFrames; frame++) {
                        const lat = centerLat + latOffset - frame * latStep;

                        for (
                            let sample = 0;
                            sample < samplesPerWaveform;
                            sample++
                        ) {
                            const lng =
                                centerLng - lngOffset + sample * lngStep;
                            locations.push({ latitude: lat, longitude: lng });
                        }
                    }

                    return locations;
                }

                /**
                 * Fetch elevation data with caching.
                 */
                async fetchElevation(centerLat, centerLng) {
                    const cacheKey = this.getCacheKey(centerLat, centerLng);

                    if (this.cache.has(cacheKey)) {
                        console.log("Using cached terrain data");
                        return this.cache.get(cacheKey);
                    }

                    const locations = this.generateGridLocations(
                        centerLat,
                        centerLng,
                        CONFIG.wavetable,
                    );

                    console.log(
                        `Fetching ${locations.length} elevation points...`,
                    );

                    let result;
                    try {
                        result = await this.fetchWithChunking(
                            locations,
                            CONFIG.api.primary,
                            "primary",
                        );
                    } catch (primaryError) {
                        console.warn(
                            "Primary API failed:",
                            primaryError.message,
                        );
                        app.setStatus(
                            "Primary API failed, trying backup...",
                            "warning",
                        );

                        try {
                            result =
                                await this.fetchFromOpenTopoData(locations);
                        } catch (fallbackError) {
                            console.warn(
                                "Fallback API failed:",
                                fallbackError.message,
                            );
                            app.setStatus(
                                "APIs unavailable, using demo terrain",
                                "warning",
                            );
                            result = this.generateDemoTerrain(
                                centerLat,
                                centerLng,
                            );
                        }
                    }

                    this.cache.set(cacheKey, result);
                    return result;
                }

                /**
                 * Fetch with chunking to avoid API timeouts.
                 */
                async fetchWithChunking(locations, apiUrl, apiName) {
                    const { maxLocationsPerRequest, delayBetweenChunks } =
                        CONFIG.api;
                    const chunks = [];

                    for (
                        let i = 0;
                        i < locations.length;
                        i += maxLocationsPerRequest
                    ) {
                        chunks.push(
                            locations.slice(i, i + maxLocationsPerRequest),
                        );
                    }

                    const results = [];
                    for (let i = 0; i < chunks.length; i++) {
                        app.setStatus(
                            `Fetching terrain (${apiName})... ${i + 1}/${chunks.length}`,
                            "loading",
                        );

                        const fetchUrl = CONFIG.api.corsProxy
                            ? CONFIG.api.corsProxy + encodeURIComponent(apiUrl)
                            : apiUrl;
                        const response = await fetch(fetchUrl, {
                            method: "POST",
                            headers: {
                                Accept: "application/json",
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({ locations: chunks[i] }),
                        });

                        if (!response.ok) {
                            throw new Error(`API returned ${response.status}`);
                        }

                        const data = await response.json();

                        if (!data.results || data.results.length === 0) {
                            throw new Error("No results in API response");
                        }

                        results.push(
                            ...data.results.map((r) => r.elevation ?? 0),
                        );

                        if (i < chunks.length - 1) {
                            await this.sleep(delayBetweenChunks);
                        }
                    }

                    console.log(`Received ${results.length} elevation points`);
                    return this.normalizeToWavetable(results);
                }

                /**
                 * Fetch from Open Topo Data.
                 */
                async fetchFromOpenTopoData(locations) {
                    const { maxLocationsPerRequest, delayBetweenChunks } =
                        CONFIG.api;
                    const chunks = [];

                    for (
                        let i = 0;
                        i < locations.length;
                        i += maxLocationsPerRequest
                    ) {
                        chunks.push(
                            locations.slice(i, i + maxLocationsPerRequest),
                        );
                    }

                    const results = [];
                    for (let i = 0; i < chunks.length; i++) {
                        app.setStatus(
                            `Fetching terrain (backup)... ${i + 1}/${chunks.length}`,
                            "loading",
                        );

                        const locString = chunks[i]
                            .map((l) => `${l.latitude},${l.longitude}`)
                            .join("|");

                        const fallbackUrl = `${CONFIG.api.fallback}?locations=${locString}`;
                        const fetchUrl = CONFIG.api.corsProxy
                            ? CONFIG.api.corsProxy +
                              encodeURIComponent(fallbackUrl)
                            : fallbackUrl;
                        const response = await fetch(fetchUrl);

                        if (!response.ok) {
                            throw new Error(
                                `Fallback API returned ${response.status}`,
                            );
                        }

                        const data = await response.json();

                        if (!data.results || data.results.length === 0) {
                            throw new Error(
                                "No results in fallback API response",
                            );
                        }

                        results.push(
                            ...data.results.map((r) => r.elevation ?? 0),
                        );

                        if (i < chunks.length - 1) {
                            await this.sleep(delayBetweenChunks);
                        }
                    }

                    console.log(
                        `Received ${results.length} elevation points from fallback`,
                    );
                    return this.normalizeToWavetable(results);
                }

                /**
                 * Generate procedural terrain for demo/fallback.
                 */
                generateDemoTerrain(centerLat = 0, centerLng = 0) {
                    console.warn(
                        "TerrainService: USING DEMO TERRAIN (APIs failed)",
                    );
                    const { samplesPerWaveform, numberOfFrames } =
                        CONFIG.wavetable;
                    const elevations = [];

                    // Use coordinates as seed for variation
                    const seed = (centerLat * 1000 + centerLng) % 1000;

                    for (let f = 0; f < numberOfFrames; f++) {
                        for (let s = 0; s < samplesPerWaveform; s++) {
                            const value =
                                Math.sin(s * 0.05 + seed * 0.01) * 500 +
                                Math.sin(s * 0.1 + f * 0.2 + seed * 0.02) *
                                    300 +
                                Math.sin(s * 0.02 - f * 0.1 + seed * 0.03) *
                                    200 +
                                Math.sin(s * 0.25 + f * 0.5) * 100;
                            elevations.push(value);
                        }
                    }

                    console.log("Generated demo terrain");
                    return this.normalizeToWavetable(elevations);
                }

                /**
                 * Normalize elevation data to wavetable format.
                 * @param {number[]} elevations - Raw elevation data
                 * @param {number} intensity - 0-100, blends between flat (0) and full terrain (100)
                 */
                normalizeToWavetable(elevations, intensity = 100) {
                    const { samplesPerWaveform, numberOfFrames } =
                        CONFIG.wavetable;

                    let globalMin = Infinity;
                    let globalMax = -Infinity;

                    for (const elev of elevations) {
                        if (
                            elev !== null &&
                            elev !== undefined &&
                            !isNaN(elev)
                        ) {
                            globalMin = Math.min(globalMin, elev);
                            globalMax = Math.max(globalMax, elev);
                        }
                    }

                    // Handle edge case of flat terrain
                    if (globalMin === globalMax) {
                        globalMax = globalMin + 1;
                    }

                    const range = globalMax - globalMin;
                    const midpoint = (globalMax + globalMin) / 2;

                    // Intensity factor: 0 = flat line, 1 = full terrain
                    const intensityFactor = intensity / 100;

                    const frames = [];
                    for (let f = 0; f < numberOfFrames; f++) {
                        const frame = new Float32Array(samplesPerWaveform);
                        const frameStart = f * samplesPerWaveform;

                        for (let s = 0; s < samplesPerWaveform; s++) {
                            const rawValue = elevations[frameStart + s] ?? 0;
                            // Full terrain value (normalized -1 to 1)
                            const terrainValue =
                                range > 0
                                    ? (rawValue - midpoint) / (range / 2)
                                    : 0;
                            // Blend between flat (0) and terrain based on intensity
                            frame[s] = terrainValue * intensityFactor;
                        }

                        frames.push(frame);
                    }

                    console.log(
                        `Normalized wavetable: ${frames.length} frames, elevation ${Math.round(globalMin)}m - ${Math.round(globalMax)}m, intensity ${intensity}%`,
                    );

                    return {
                        frames,
                        metadata: { globalMin, globalMax, range },
                        rawElevations: elevations, // Store for re-processing with different intensity
                    };
                }

                sleep(ms) {
                    return new Promise((resolve) => setTimeout(resolve, ms));
                }
            }

            // ============================================================
            // SHIMMER REVERB (Freeverb/Greyhole inspired)
            // ============================================================
            class ShimmerReverb {
                constructor(audioCtx) {
                    this.audioCtx = audioCtx;
                    this.input = audioCtx.createGain();
                    this.output = audioCtx.createGain();

                    // Parameters
                    this.decay = 0.7;
                    this.damping = 0.4;
                    this.size = 1.0;
                    this.modDepth = 0.002;
                    this.modRate = 0.5;

                    // Freeverb-style comb filter delay times (in seconds at 44.1kHz, scaled)
                    this.combTunings = [
                        0.0297, 0.0371, 0.0411, 0.0437, 0.0229, 0.0267, 0.0313,
                        0.0359,
                    ];

                    // Allpass filter delay times
                    this.allpassTunings = [0.0053, 0.0127, 0.0091, 0.0107];

                    this.combs = [];
                    this.allpasses = [];
                    this.dampFilters = [];
                    this.modOscs = [];
                    this.modGains = [];

                    this.buildGraph();
                }

                buildGraph() {
                    const ctx = this.audioCtx;

                    // Pre-delay
                    this.preDelay = ctx.createDelay(0.5);
                    this.preDelay.delayTime.value = 0.02;

                    // Input diffusion (allpass chain)
                    this.inputDiffusion = [];
                    for (let i = 0; i < 2; i++) {
                        const ap = this.createAllpass(0.005 + i * 0.003, 0.5);
                        this.inputDiffusion.push(ap);
                    }

                    // Parallel comb filters (8 total, 4 per channel for stereo)
                    const combMergerL = ctx.createGain();
                    const combMergerR = ctx.createGain();
                    combMergerL.gain.value = 0.25;
                    combMergerR.gain.value = 0.25;

                    for (let i = 0; i < 8; i++) {
                        const comb = this.createModulatedComb(
                            this.combTunings[i] * this.size,
                            this.decay,
                            i,
                        );
                        this.combs.push(comb);

                        // Route to L or R
                        if (i < 4) {
                            comb.output.connect(combMergerL);
                        } else {
                            comb.output.connect(combMergerR);
                        }
                    }

                    // Output allpass diffusion (stereo)
                    const allpassChainL = this.createAllpassChain();
                    const allpassChainR = this.createAllpassChain();

                    // Stereo output
                    this.stereoMerger = ctx.createChannelMerger(2);

                    // Connect the graph
                    this.input.connect(this.preDelay);

                    // Input diffusion chain
                    let lastNode = this.preDelay;
                    for (const ap of this.inputDiffusion) {
                        lastNode.connect(ap.input);
                        lastNode = ap.output;
                    }

                    // Fan out to combs
                    for (const comb of this.combs) {
                        lastNode.connect(comb.input);
                    }

                    // Through allpass chains to stereo output
                    combMergerL.connect(allpassChainL.input);
                    combMergerR.connect(allpassChainR.input);

                    allpassChainL.output.connect(this.stereoMerger, 0, 0);
                    allpassChainR.output.connect(this.stereoMerger, 0, 1);

                    // Cross-feed for wider stereo
                    const crossL = ctx.createGain();
                    const crossR = ctx.createGain();
                    crossL.gain.value = 0.2;
                    crossR.gain.value = 0.2;
                    allpassChainL.output.connect(crossR);
                    allpassChainR.output.connect(crossL);
                    crossL.connect(this.stereoMerger, 0, 0);
                    crossR.connect(this.stereoMerger, 0, 1);

                    this.stereoMerger.connect(this.output);
                }

                createModulatedComb(delayTime, feedback, index) {
                    const ctx = this.audioCtx;

                    const input = ctx.createGain();
                    const delay = ctx.createDelay(1.0);
                    const feedbackGain = ctx.createGain();
                    const damper = ctx.createBiquadFilter();
                    const output = ctx.createGain();

                    delay.delayTime.value = delayTime;
                    feedbackGain.gain.value = feedback;

                    // Damping filter (lowpass in feedback loop)
                    damper.type = "lowpass";
                    damper.frequency.value = 4000 * (1 - this.damping);
                    damper.Q.value = 0.5;
                    this.dampFilters.push(damper);

                    // LFO for delay time modulation (Greyhole-style shimmer)
                    const lfo = ctx.createOscillator();
                    const lfoGain = ctx.createGain();
                    lfo.type = "sine";
                    lfo.frequency.value = this.modRate * (0.8 + index * 0.1);
                    lfoGain.gain.value = this.modDepth * delayTime;
                    lfo.connect(lfoGain);
                    lfoGain.connect(delay.delayTime);
                    lfo.start();
                    this.modOscs.push(lfo);
                    this.modGains.push({ gain: lfoGain, baseDelay: delayTime });

                    // Comb filter topology
                    input.connect(delay);
                    delay.connect(output);
                    delay.connect(damper);
                    damper.connect(feedbackGain);
                    feedbackGain.connect(delay);

                    return { input, output, delay, feedbackGain, damper };
                }

                createAllpass(delayTime, feedback) {
                    const ctx = this.audioCtx;

                    const input = ctx.createGain();
                    const output = ctx.createGain();
                    const delay = ctx.createDelay(0.5);
                    const feedbackGain = ctx.createGain();
                    const feedforwardGain = ctx.createGain();

                    delay.delayTime.value = delayTime;
                    feedbackGain.gain.value = feedback;
                    feedforwardGain.gain.value = -feedback;

                    // Allpass topology
                    input.connect(delay);
                    input.connect(feedforwardGain);
                    delay.connect(output);
                    delay.connect(feedbackGain);
                    feedbackGain.connect(input);
                    feedforwardGain.connect(output);

                    return { input, output, delay };
                }

                createAllpassChain() {
                    const ctx = this.audioCtx;
                    const input = ctx.createGain();
                    const output = ctx.createGain();

                    let lastNode = input;
                    for (const time of this.allpassTunings) {
                        const ap = this.createAllpass(time * this.size, 0.5);
                        this.allpasses.push(ap);
                        lastNode.connect(ap.input);
                        lastNode = ap.output;
                    }
                    lastNode.connect(output);

                    return { input, output };
                }

                setDecay(value) {
                    // value 0-1, map to feedback 0.5-0.9 (safer range to avoid runaway)
                    this.decay = 0.5 + value * 0.4;
                    for (const comb of this.combs) {
                        comb.feedbackGain.gain.setValueAtTime(
                            this.decay,
                            this.audioCtx.currentTime,
                        );
                    }
                }

                setDamping(value) {
                    // value 0-1
                    this.damping = value;
                    const freq = 8000 * (1 - value * 0.8);
                    for (const filter of this.dampFilters) {
                        filter.frequency.setValueAtTime(
                            freq,
                            this.audioCtx.currentTime,
                        );
                    }
                }

                setSize(value) {
                    // value 0-1, affects delay times
                    this.size = 0.5 + value * 1.5;
                    this.combs.forEach((comb, i) => {
                        const newTime = this.combTunings[i] * this.size;
                        comb.delay.delayTime.setValueAtTime(
                            newTime,
                            this.audioCtx.currentTime,
                        );
                    });
                }

                setModulation(depth, rate) {
                    this.modDepth = depth;
                    this.modRate = rate;
                    this.modOscs.forEach((osc, i) => {
                        osc.frequency.setValueAtTime(
                            rate * (0.8 + i * 0.1),
                            this.audioCtx.currentTime,
                        );
                    });
                    this.modGains.forEach((mg) => {
                        mg.gain.gain.setValueAtTime(
                            depth * mg.baseDelay,
                            this.audioCtx.currentTime,
                        );
                    });
                }

                setPreDelay(ms) {
                    // value in milliseconds (0-100)
                    const seconds = ms / 1000;
                    this.preDelay.delayTime.setValueAtTime(
                        seconds,
                        this.audioCtx.currentTime,
                    );
                }
            }

            // ============================================================
            // AUDIO ENGINE
            // ============================================================
            class AudioEngine {
                constructor() {
                    this.audioCtx = null;
                    this.masterGain = null;
                    this.filter = null;
                    this.dryGain = null;
                    this.wetGain = null;
                    this.reverb = null;
                    this.periodicWaves = [];
                    this.voices = new Map();
                    this.morphPosition = 0.5;
                    this.adsr = {
                        attack: 0.01,
                        decay: 0.1,
                        sustain: 0.7,
                        release: 0.3,
                    };
                    this.filterCutoff = 20000;
                    this.filterResonance = 0;
                    this.reverbMix = 0;
                    this.reverbDecay = 0.5;
                    this.initialized = false;
                }

                async initialize() {
                    if (this.initialized) return;

                    this.audioCtx = new (
                        window.AudioContext || window.webkitAudioContext
                    )();

                    // Create filter (low-pass)
                    this.filter = this.audioCtx.createBiquadFilter();
                    this.filter.type = "lowpass";
                    this.filter.frequency.value = this.filterCutoff;
                    this.filter.Q.value = this.filterResonance;

                    // Create shimmer reverb
                    this.reverb = new ShimmerReverb(this.audioCtx);

                    // Dry/wet mix for reverb
                    this.dryGain = this.audioCtx.createGain();
                    this.wetGain = this.audioCtx.createGain();
                    this.dryGain.gain.value = 1;
                    this.wetGain.gain.value = 0;

                    // Master gain
                    this.masterGain = this.audioCtx.createGain();
                    this.masterGain.gain.value = 0.7;

                    // Signal routing:
                    // voices -> filter -> dryGain -> masterGain -> destination
                    //                  -> reverb -> wetGain -> masterGain
                    this.filter.connect(this.dryGain);
                    this.filter.connect(this.reverb.input);
                    this.reverb.output.connect(this.wetGain);
                    this.dryGain.connect(this.masterGain);
                    this.wetGain.connect(this.masterGain);
                    this.masterGain.connect(this.audioCtx.destination);

                    this.loadDefaultWave();

                    this.initialized = true;
                    console.log("Audio engine initialized");
                }

                setFilterCutoff(frequency) {
                    this.filterCutoff = frequency;
                    if (this.filter) {
                        this.filter.frequency.setValueAtTime(
                            frequency,
                            this.audioCtx.currentTime,
                        );
                    }
                }

                setFilterResonance(q) {
                    this.filterResonance = q;
                    if (this.filter) {
                        this.filter.Q.setValueAtTime(
                            q,
                            this.audioCtx.currentTime,
                        );
                    }
                }

                setReverbMix(mix) {
                    this.reverbMix = mix;
                    if (this.dryGain && this.wetGain) {
                        this.dryGain.gain.setValueAtTime(
                            1 - mix * 0.5,
                            this.audioCtx.currentTime,
                        );
                        this.wetGain.gain.setValueAtTime(
                            mix,
                            this.audioCtx.currentTime,
                        );
                    }
                }

                setReverbDecay(decay) {
                    // decay slider 0.1-5 maps to 0-1 for reverb
                    this.reverbDecay = decay;
                    if (this.reverb) {
                        const normalized = Math.min(1, (decay - 0.1) / 4.9);
                        this.reverb.setDecay(normalized);
                    }
                }

                setReverbDamping(damping) {
                    if (this.reverb) {
                        this.reverb.setDamping(damping);
                    }
                }

                setReverbSize(size) {
                    if (this.reverb) {
                        this.reverb.setSize(size);
                    }
                }

                setReverbPreDelay(ms) {
                    if (this.reverb) {
                        this.reverb.setPreDelay(ms);
                    }
                }

                setReverbShimmer(amount) {
                    if (this.reverb) {
                        // Shimmer controls modulation depth (0-0.01) and rate (0.3-2)
                        const depth = amount * 0.01;
                        const rate = 0.3 + amount * 1.7;
                        this.reverb.setModulation(depth, rate);
                    }
                }

                loadDefaultWave() {
                    const real = new Float32Array(2);
                    const imag = new Float32Array(2);
                    real[0] = 0;
                    imag[0] = 0;
                    real[1] = 0;
                    imag[1] = 1;

                    const wave = this.audioCtx.createPeriodicWave(real, imag);
                    this.periodicWaves = [wave];
                }

                loadWavetable(frames) {
                    if (!this.initialized) {
                        console.warn("Audio not initialized");
                        return;
                    }

                    this.periodicWaves = frames.map((frame) =>
                        this.frameToPeriodicWave(frame),
                    );
                    console.log(
                        `Audio: Loaded ${this.periodicWaves.length} wavetable frames`,
                    );
                }

                frameToPeriodicWave(frame) {
                    const n = frame.length;
                    const real = new Float32Array(n / 2);
                    const imag = new Float32Array(n / 2);

                    for (let k = 0; k < n / 2; k++) {
                        let sumReal = 0;
                        let sumImag = 0;

                        for (let t = 0; t < n; t++) {
                            const angle = (2 * Math.PI * k * t) / n;
                            sumReal += frame[t] * Math.cos(angle);
                            sumImag -= frame[t] * Math.sin(angle);
                        }

                        real[k] = sumReal / n;
                        imag[k] = sumImag / n;
                    }

                    real[0] = 0;
                    imag[0] = 0;

                    return this.audioCtx.createPeriodicWave(real, imag, {
                        disableNormalization: false,
                    });
                }

                noteOn(noteId, frequency, velocity = 1.0) {
                    if (!this.initialized || this.periodicWaves.length === 0)
                        return;

                    this.noteOff(noteId);

                    const voice = this.createVoice(frequency, velocity);
                    this.voices.set(noteId, voice);

                    this.triggerAttack(voice.envGain);

                    voice.oscA.start();
                    voice.oscB.start();
                }

                createVoice(frequency, velocity) {
                    const oscA = this.audioCtx.createOscillator();
                    const oscB = this.audioCtx.createOscillator();
                    const gainA = this.audioCtx.createGain();
                    const gainB = this.audioCtx.createGain();
                    const envGain = this.audioCtx.createGain();
                    const velGain = this.audioCtx.createGain();

                    oscA.connect(gainA);
                    oscB.connect(gainB);
                    gainA.connect(envGain);
                    gainB.connect(envGain);
                    envGain.connect(velGain);
                    // Connect to filter (which then goes to reverb/master)
                    velGain.connect(this.filter);

                    oscA.frequency.value = frequency;
                    oscB.frequency.value = frequency;

                    velGain.gain.value = velocity;

                    this.applyMorph({ oscA, oscB, gainA, gainB });

                    envGain.gain.value = 0;

                    return { oscA, oscB, gainA, gainB, envGain, velGain };
                }

                applyMorph(voice) {
                    if (this.periodicWaves.length <= 1) {
                        voice.oscA.setPeriodicWave(this.periodicWaves[0]);
                        voice.oscB.setPeriodicWave(this.periodicWaves[0]);
                        voice.gainA.gain.value = 1;
                        voice.gainB.gain.value = 0;
                        return;
                    }

                    const frameIndex =
                        this.morphPosition * (this.periodicWaves.length - 1);
                    const lowerFrame = Math.floor(frameIndex);
                    const upperFrame = Math.min(
                        lowerFrame + 1,
                        this.periodicWaves.length - 1,
                    );
                    const blend = frameIndex - lowerFrame;

                    voice.oscA.setPeriodicWave(this.periodicWaves[lowerFrame]);
                    voice.oscB.setPeriodicWave(this.periodicWaves[upperFrame]);
                    voice.gainA.gain.value = 1 - blend;
                    voice.gainB.gain.value = blend;
                }

                noteOff(noteId) {
                    const voice = this.voices.get(noteId);
                    if (!voice) return;

                    this.triggerRelease(voice.envGain);

                    const stopTime =
                        this.audioCtx.currentTime + this.adsr.release + 0.1;
                    voice.oscA.stop(stopTime);
                    voice.oscB.stop(stopTime);

                    this.voices.delete(noteId);
                }

                triggerAttack(gainNode) {
                    const now = this.audioCtx.currentTime;
                    gainNode.gain.cancelScheduledValues(now);
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(
                        1,
                        now + this.adsr.attack,
                    );
                    gainNode.gain.linearRampToValueAtTime(
                        this.adsr.sustain,
                        now + this.adsr.attack + this.adsr.decay,
                    );
                }

                triggerRelease(gainNode) {
                    const now = this.audioCtx.currentTime;
                    gainNode.gain.cancelScheduledValues(now);
                    gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                    gainNode.gain.linearRampToValueAtTime(
                        0,
                        now + this.adsr.release,
                    );
                }

                setMorphPosition(position) {
                    this.morphPosition = Math.max(0, Math.min(1, position));

                    for (const voice of this.voices.values()) {
                        this.applyMorph(voice);
                    }
                }

                setMasterVolume(volume) {
                    if (this.masterGain) {
                        this.masterGain.gain.value = volume;
                    }
                }

                setADSR(attack, decay, sustain, release) {
                    this.adsr = { attack, decay, sustain, release };
                }
            }

            // ============================================================
            // MIDI CONTROLLER
            // ============================================================
            class MidiController {
                constructor(onNoteOn, onNoteOff, onCC) {
                    this.onNoteOn = onNoteOn;
                    this.onNoteOff = onNoteOff;
                    this.onCC = onCC;
                    this.midiAccess = null;
                    this.inputs = [];
                }

                async initialize() {
                    if (!navigator.requestMIDIAccess) {
                        console.log("Web MIDI not supported");
                        return false;
                    }

                    try {
                        this.midiAccess = await navigator.requestMIDIAccess();
                        this.setupInputs();
                        this.midiAccess.onstatechange = () =>
                            this.setupInputs();
                        return true;
                    } catch (err) {
                        console.warn("MIDI access denied:", err);
                        return false;
                    }
                }

                setupInputs() {
                    this.inputs = [];

                    for (const input of this.midiAccess.inputs.values()) {
                        input.onmidimessage = (e) => this.handleMessage(e);
                        this.inputs.push(input);
                    }

                    if (this.inputs.length > 0) {
                        const names = this.inputs.map((i) => i.name).join(", ");
                        app.setMidiStatus(true, names);
                    } else {
                        app.setMidiStatus(false, "No MIDI devices");
                    }
                }

                handleMessage(event) {
                    const [status, data1, data2] = event.data;
                    const command = status >> 4;

                    switch (command) {
                        case 0x9:
                            if (data2 > 0) {
                                const frequency =
                                    this.midiNoteToFrequency(data1);
                                const velocity = data2 / 127;
                                this.onNoteOn(data1, frequency, velocity);
                            } else {
                                this.onNoteOff(data1);
                            }
                            break;

                        case 0x8:
                            this.onNoteOff(data1);
                            break;

                        case 0xb:
                            this.onCC(data1, data2 / 127);
                            break;
                    }
                }

                midiNoteToFrequency(note) {
                    return 440 * Math.pow(2, (note - 69) / 12);
                }
            }

            // ============================================================
            // 3D TERRAIN VISUALIZATION (Three.js)
            // ============================================================
            class Terrain3DDisplay {
                constructor(canvas) {
                    this.canvas = canvas;
                    this.frames = [];
                    this.morphPosition = 0.5;
                    this.isLightMode = false;

                    this.scene = null;
                    this.camera = null;
                    this.renderer = null;
                    this.controls = null;
                    this.terrainMesh = null;
                    this.morphLine = null;

                    this.init();
                }

                init() {
                    // Scene
                    this.scene = new THREE.Scene();

                    // Camera
                    this.camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
                    this.camera.position.set(2, 1.5, 2);

                    // Renderer
                    this.renderer = new THREE.WebGLRenderer({
                        canvas: this.canvas,
                        antialias: true,
                        alpha: true,
                    });
                    this.renderer.setPixelRatio(window.devicePixelRatio);
                    this.updateColors();

                    // Controls
                    this.controls = new THREE.OrbitControls(
                        this.camera,
                        this.canvas,
                    );
                    this.controls.enableDamping = true;
                    this.controls.dampingFactor = 0.05;
                    this.controls.enablePan = false;
                    this.controls.minDistance = 1;
                    this.controls.maxDistance = 5;

                    // Initial resize
                    this.resize();

                    // Animation loop
                    this.animate();

                    // Resize observer
                    this.resizeObserver = new ResizeObserver(() =>
                        this.resize(),
                    );
                    this.resizeObserver.observe(this.canvas.parentElement);
                }

                resize() {
                    const rect =
                        this.canvas.parentElement.getBoundingClientRect();
                    const width = rect.width;
                    const height = rect.height;

                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(width, height);
                }

                updateColors() {
                    const bgColor = this.isLightMode ? 0xf5f5f5 : 0x0a0a0a;
                    this.renderer.setClearColor(bgColor, 1);

                    // Update terrain material if it exists
                    if (this.terrainMesh) {
                        this.terrainMesh.material.color.setHex(
                            this.isLightMode ? 0x000000 : 0xffffff,
                        );
                    }

                    // Update morph line if it exists (arctic blue for visibility)
                    if (this.morphLine) {
                        this.morphLine.material.color.setHex(
                            this.isLightMode ? 0x0088cc : 0x66ccff,
                        );
                    }
                }

                setLightMode(isLight) {
                    this.isLightMode = isLight;
                    this.updateColors();
                }

                setFrames(frames, resetCamera = true) {
                    console.log(
                        `Terrain3D.setFrames: received ${frames.length} frames`,
                    );
                    this.frames = frames;
                    this.buildTerrain(resetCamera);
                }

                setMorphPosition(position) {
                    this.morphPosition = position;
                    this.updateMorphLine();
                }

                buildTerrain(resetCamera = true) {
                    console.log("Terrain3D.buildTerrain: starting rebuild...");

                    // Remove old mesh
                    if (this.terrainMesh) {
                        this.scene.remove(this.terrainMesh);
                        this.terrainMesh.geometry.dispose();
                        this.terrainMesh.material.dispose();
                        console.log("Terrain3D.buildTerrain: removed old mesh");
                    }
                    if (this.morphLine) {
                        this.scene.remove(this.morphLine);
                        this.morphLine.geometry.dispose();
                        this.morphLine.material.dispose();
                    }

                    if (this.frames.length === 0) {
                        console.log(
                            "Terrain3D.buildTerrain: no frames, skipping",
                        );
                        return;
                    }

                    const numFrames = this.frames.length;
                    const samplesPerFrame = this.frames[0].length;

                    // Log some sample values to verify data is different
                    console.log(
                        `Terrain3D.buildTerrain: ${numFrames} frames x ${samplesPerFrame} samples`,
                    );
                    console.log(
                        "Terrain3D.buildTerrain: sample values from frame 0:",
                        this.frames[0][0].toFixed(3),
                        this.frames[0][Math.floor(samplesPerFrame / 2)].toFixed(
                            3,
                        ),
                        this.frames[0][samplesPerFrame - 1].toFixed(3),
                    );

                    // Create geometry
                    const geometry = new THREE.BufferGeometry();
                    const vertices = [];
                    const indices = [];

                    // Downsample for performance
                    const frameStep = Math.max(1, Math.floor(numFrames / 32));
                    const sampleStep = Math.max(
                        1,
                        Math.floor(samplesPerFrame / 64),
                    );

                    const actualFrames = [];
                    const actualSamples = [];

                    for (let f = 0; f < numFrames; f += frameStep) {
                        actualFrames.push(f);
                    }
                    for (let s = 0; s < samplesPerFrame; s += sampleStep) {
                        actualSamples.push(s);
                    }

                    // Generate vertices
                    for (let fi = 0; fi < actualFrames.length; fi++) {
                        const f = actualFrames[fi];
                        const z = fi / (actualFrames.length - 1) - 0.5; // -0.5 to 0.5

                        for (let si = 0; si < actualSamples.length; si++) {
                            const s = actualSamples[si];
                            const x = si / (actualSamples.length - 1) - 0.5; // -0.5 to 0.5
                            const y = this.frames[f][s] * 0.3; // Height scale

                            vertices.push(x, y, z);
                        }
                    }

                    // Generate indices for wireframe
                    const cols = actualSamples.length;
                    const rows = actualFrames.length;

                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols - 1; c++) {
                            const i = r * cols + c;
                            indices.push(i, i + 1);
                        }
                    }

                    for (let c = 0; c < cols; c++) {
                        for (let r = 0; r < rows - 1; r++) {
                            const i = r * cols + c;
                            indices.push(i, i + cols);
                        }
                    }

                    geometry.setAttribute(
                        "position",
                        new THREE.Float32BufferAttribute(vertices, 3),
                    );
                    geometry.setIndex(indices);

                    // Create wireframe material (subtle, so morph line stands out)
                    const material = new THREE.LineBasicMaterial({
                        color: this.isLightMode ? 0x000000 : 0xffffff,
                        linewidth: 1,
                        transparent: true,
                        opacity: 0.25,
                    });

                    this.terrainMesh = new THREE.LineSegments(
                        geometry,
                        material,
                    );
                    this.terrainMesh.scale.setScalar(1.3);
                    this.scene.add(this.terrainMesh);

                    // Create morph line
                    this.createMorphLine();

                    // Reset camera (optionally)
                    if (resetCamera) {
                        this.resetView();
                    }
                }

                createMorphLine() {
                    if (this.frames.length === 0) return;

                    const samplesPerFrame = this.frames[0].length;
                    const sampleStep = Math.max(
                        1,
                        Math.floor(samplesPerFrame / 64),
                    );

                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(
                        Math.ceil(samplesPerFrame / sampleStep) * 3,
                    );

                    geometry.setAttribute(
                        "position",
                        new THREE.BufferAttribute(positions, 3),
                    );

                    const material = new THREE.LineBasicMaterial({
                        color: this.isLightMode ? 0x0088cc : 0x66ccff,
                        linewidth: 3,
                        transparent: true,
                        opacity: 1,
                    });

                    this.morphLine = new THREE.Line(geometry, material);
                    this.morphLine.scale.setScalar(1.3);
                    this.scene.add(this.morphLine);

                    this.updateMorphLine();
                }

                updateMorphLine() {
                    if (!this.morphLine || this.frames.length === 0) return;

                    const numFrames = this.frames.length;
                    const samplesPerFrame = this.frames[0].length;
                    const sampleStep = Math.max(
                        1,
                        Math.floor(samplesPerFrame / 64),
                    );

                    // Interpolate frame
                    const frameIndex = this.morphPosition * (numFrames - 1);
                    const lowerIndex = Math.floor(frameIndex);
                    const upperIndex = Math.min(lowerIndex + 1, numFrames - 1);
                    const blend = frameIndex - lowerIndex;

                    const z = this.morphPosition - 0.5;

                    const positions =
                        this.morphLine.geometry.attributes.position.array;
                    let idx = 0;

                    for (let s = 0; s < samplesPerFrame; s += sampleStep) {
                        const x = s / (samplesPerFrame - 1) - 0.5;
                        const yLower = this.frames[lowerIndex][s];
                        const yUpper = this.frames[upperIndex][s];
                        const y = (yLower * (1 - blend) + yUpper * blend) * 0.3;

                        positions[idx++] = x;
                        positions[idx++] = y;
                        positions[idx++] = z;
                    }

                    this.morphLine.geometry.attributes.position.needsUpdate = true;
                }

                resetView() {
                    this.camera.position.set(2, 1.5, 2);
                    this.camera.lookAt(0, 0, 0);
                    this.controls.reset();
                }

                animate = () => {
                    requestAnimationFrame(this.animate);
                    this.controls.update();
                    this.renderer.render(this.scene, this.camera);
                };
            }

            // ============================================================
            // WAVEFORM DISPLAY (2D Canvas)
            // ============================================================
            class WaveformDisplay {
                constructor(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext("2d");
                    this.frames = [];
                    this.morphPosition = 0.5;
                    this.isLightMode = false;
                    this.resizeObserver = new ResizeObserver(() =>
                        this.resize(),
                    );
                    this.resizeObserver.observe(canvas.parentElement);
                    this.resize();
                }

                resize() {
                    const rect =
                        this.canvas.parentElement.getBoundingClientRect();
                    this.canvas.width = rect.width;
                    this.canvas.height = rect.height;
                    this.draw();
                }

                setLightMode(isLight) {
                    this.isLightMode = isLight;
                    this.draw();
                }

                setFrames(frames) {
                    this.frames = frames;
                    console.log(
                        `WaveformDisplay: received ${frames.length} frames`,
                    );
                    this.draw();
                }

                setMorphPosition(position) {
                    this.morphPosition = position;
                    this.draw();
                }

                draw() {
                    const { ctx, canvas, frames, morphPosition, isLightMode } =
                        this;
                    const { width, height } = canvas;
                    const padding = 20;

                    const bgColor = isLightMode ? "#f5f5f5" : "#000000";
                    const lineColor = isLightMode ? "#000000" : "#ffffff";
                    const mutedColor = isLightMode ? "#dddddd" : "#222222";

                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, width, height);

                    if (frames.length === 0) {
                        ctx.strokeStyle = mutedColor;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(padding, height / 2);
                        ctx.lineTo(width - padding, height / 2);
                        ctx.stroke();
                        return;
                    }

                    const frame = this.getInterpolatedFrame(morphPosition);

                    ctx.strokeStyle = lineColor;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();

                    const drawWidth = width - padding * 2;
                    const drawHeight = height - padding * 2;
                    const centerY = height / 2;
                    const stepX = drawWidth / (frame.length - 1);

                    for (let i = 0; i < frame.length; i++) {
                        const x = padding + i * stepX;
                        const y = centerY - frame[i] * (drawHeight / 2) * 0.9;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }

                    ctx.stroke();
                }

                getInterpolatedFrame(position) {
                    if (this.frames.length === 0) return new Float32Array(0);
                    if (this.frames.length === 1) return this.frames[0];

                    const frameIndex = position * (this.frames.length - 1);
                    const lowerIndex = Math.floor(frameIndex);
                    const upperIndex = Math.min(
                        lowerIndex + 1,
                        this.frames.length - 1,
                    );
                    const blend = frameIndex - lowerIndex;

                    const lower = this.frames[lowerIndex];
                    const upper = this.frames[upperIndex];
                    const result = new Float32Array(lower.length);

                    for (let i = 0; i < lower.length; i++) {
                        result[i] = lower[i] * (1 - blend) + upper[i] * blend;
                    }

                    return result;
                }
            }

            // ============================================================
            // MAP CONTROLLER
            // ============================================================
            class MapController {
                constructor(containerId, onLocationSelect) {
                    this.containerId = containerId;
                    this.onLocationSelect = onLocationSelect;
                    this.map = null;
                    this.marker = null;
                    this.areaRect = null;
                }

                initialize() {
                    this.map = L.map(this.containerId, {
                        center: CONFIG.map.defaultCenter,
                        zoom: CONFIG.map.defaultZoom,
                        zoomControl: true,
                    });

                    L.tileLayer(
                        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                        {
                            attribution: "Â© OpenStreetMap",
                        },
                    ).addTo(this.map);

                    this.map.on("click", (e) => {
                        const { lat, lng } = e.latlng;
                        this.showSelection(lat, lng);
                        this.onLocationSelect(lat, lng);
                    });
                }

                goTo(lat, lng, zoom = 10) {
                    this.map.setView([lat, lng], zoom);
                    this.showSelection(lat, lng);
                    this.onLocationSelect(lat, lng);
                }

                showSelection(lat, lng) {
                    if (this.marker) this.map.removeLayer(this.marker);
                    if (this.areaRect) this.map.removeLayer(this.areaRect);

                    this.marker = L.circleMarker([lat, lng], {
                        radius: 6,
                        color: "#ffffff",
                        fillColor: "#ffffff",
                        fillOpacity: 1,
                        weight: 2,
                    }).addTo(this.map);

                    const latOffset = CONFIG.wavetable.gridSizeKm / 2 / 111.0;
                    const lngOffset =
                        CONFIG.wavetable.gridSizeKm /
                        2 /
                        (111.0 * Math.cos((lat * Math.PI) / 180));

                    const bounds = [
                        [lat - latOffset, lng - lngOffset],
                        [lat + latOffset, lng + lngOffset],
                    ];

                    this.areaRect = L.rectangle(bounds, {
                        color: "#ffffff",
                        weight: 1,
                        fillOpacity: 0.1,
                    }).addTo(this.map);
                }
            }

            // ============================================================
            // SEARCH SERVICE
            // ============================================================
            class SearchService {
                /**
                 * Search for a location using Nominatim (OpenStreetMap).
                 */
                async search(query) {
                    // First check if it's coordinates (lat, lng)
                    const coordMatch = query.match(
                        /^(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)$/,
                    );
                    if (coordMatch) {
                        return {
                            lat: parseFloat(coordMatch[1]),
                            lng: parseFloat(coordMatch[2]),
                            name: `${coordMatch[1]}, ${coordMatch[2]}`,
                        };
                    }

                    // Otherwise search via Nominatim
                    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`;

                    const response = await fetch(url, {
                        headers: {
                            "User-Agent":
                                "Carta Terrain Synth (educational project)",
                        },
                    });

                    if (!response.ok) {
                        throw new Error("Search failed");
                    }

                    const results = await response.json();

                    if (results.length === 0) {
                        throw new Error("Location not found");
                    }

                    const result = results[0];
                    return {
                        lat: parseFloat(result.lat),
                        lng: parseFloat(result.lon),
                        name: result.display_name,
                    };
                }
            }

            // ============================================================
            // KEYBOARD INPUT
            // ============================================================
            class KeyboardInput {
                constructor(onNoteOn, onNoteOff) {
                    this.onNoteOn = onNoteOn;
                    this.onNoteOff = onNoteOff;
                    this.activeKeys = new Set();
                    this.keyElements = document.querySelectorAll(".key");
                    this.keyMap = new Map();

                    this.keyElements.forEach((el) => {
                        const key = el.dataset.key;
                        const freq = parseFloat(el.dataset.freq);
                        this.keyMap.set(key, { element: el, frequency: freq });
                    });
                }

                enable() {
                    document.addEventListener("keydown", this.handleKeyDown);
                    document.addEventListener("keyup", this.handleKeyUp);

                    this.keyElements.forEach((el) => {
                        el.addEventListener("mousedown", this.handleMouseDown);
                        el.addEventListener("mouseup", this.handleMouseUp);
                        el.addEventListener("mouseleave", this.handleMouseUp);
                        el.addEventListener(
                            "touchstart",
                            this.handleTouchStart,
                        );
                        el.addEventListener("touchend", this.handleTouchEnd);
                    });
                }

                handleKeyDown = (e) => {
                    if (e.target.tagName === "INPUT") return;

                    const key = e.key.toLowerCase();
                    if (this.keyMap.has(key) && !this.activeKeys.has(key)) {
                        this.activeKeys.add(key);
                        const { element, frequency } = this.keyMap.get(key);
                        element.classList.add("active");
                        this.onNoteOn(`kb_${key}`, frequency, 0.8);
                    }
                };

                handleKeyUp = (e) => {
                    const key = e.key.toLowerCase();
                    if (this.keyMap.has(key)) {
                        this.activeKeys.delete(key);
                        const { element } = this.keyMap.get(key);
                        element.classList.remove("active");
                        this.onNoteOff(`kb_${key}`);
                    }
                };

                handleMouseDown = (e) => {
                    const key = e.currentTarget.dataset.key;
                    const freq = parseFloat(e.currentTarget.dataset.freq);
                    e.currentTarget.classList.add("active");
                    this.onNoteOn(`mouse_${key}`, freq, 0.8);
                };

                handleMouseUp = (e) => {
                    const key = e.currentTarget.dataset.key;
                    e.currentTarget.classList.remove("active");
                    this.onNoteOff(`mouse_${key}`);
                };

                handleTouchStart = (e) => {
                    e.preventDefault();
                    this.handleMouseDown(e);
                };

                handleTouchEnd = (e) => {
                    e.preventDefault();
                    this.handleMouseUp(e);
                };
            }

            // ============================================================
            // CUSTOM SELECT DROPDOWN
            // ============================================================
            class CustomSelect {
                constructor(selectElement) {
                    this.select = selectElement;
                    this.wrapper = null;
                    this.trigger = null;
                    this.optionsList = null;
                    this.isOpen = false;

                    this.build();
                    this.bindEvents();
                }

                build() {
                    // Create wrapper
                    this.wrapper = document.createElement("div");
                    this.wrapper.className = "custom-select";
                    if (this.select.dataset.tooltip) {
                        this.wrapper.dataset.tooltip =
                            this.select.dataset.tooltip;
                    }

                    // Create trigger button
                    this.trigger = document.createElement("div");
                    this.trigger.className = "custom-select-trigger";

                    const selectedText = document.createElement("span");
                    selectedText.className = "custom-select-value";
                    selectedText.textContent =
                        this.select.options[this.select.selectedIndex]?.text ||
                        "";

                    const arrow = document.createElement("span");
                    arrow.className = "custom-select-arrow";
                    arrow.innerHTML =
                        '<svg viewBox="0 0 8 8"><path d="M0 2l4 4 4-4z"/></svg>';

                    this.trigger.appendChild(selectedText);
                    this.trigger.appendChild(arrow);

                    // Create options list
                    this.optionsList = document.createElement("div");
                    this.optionsList.className = "custom-select-options";

                    Array.from(this.select.options).forEach((option, index) => {
                        const optionEl = document.createElement("div");
                        optionEl.className = "custom-select-option";
                        if (index === this.select.selectedIndex) {
                            optionEl.classList.add("selected");
                        }
                        optionEl.textContent = option.text;
                        optionEl.dataset.value = option.value;
                        optionEl.dataset.index = index;
                        this.optionsList.appendChild(optionEl);
                    });

                    // Wrap the original select
                    this.select.parentNode.insertBefore(
                        this.wrapper,
                        this.select,
                    );
                    this.wrapper.appendChild(this.trigger);
                    this.wrapper.appendChild(this.optionsList);
                    this.wrapper.appendChild(this.select);
                }

                bindEvents() {
                    // Toggle on trigger click
                    this.trigger.addEventListener("click", (e) => {
                        e.stopPropagation();
                        this.toggle();
                    });

                    // Select option on click
                    this.optionsList.addEventListener("click", (e) => {
                        const option = e.target.closest(
                            ".custom-select-option",
                        );
                        if (option) {
                            this.selectOption(parseInt(option.dataset.index));
                        }
                    });

                    // Close on outside click
                    document.addEventListener("click", (e) => {
                        if (!this.wrapper.contains(e.target)) {
                            this.close();
                        }
                    });

                    // Keyboard navigation
                    this.wrapper.addEventListener("keydown", (e) => {
                        if (e.key === "Enter" || e.key === " ") {
                            e.preventDefault();
                            this.toggle();
                        } else if (e.key === "Escape") {
                            this.close();
                        } else if (e.key === "ArrowDown") {
                            e.preventDefault();
                            this.navigateOptions(1);
                        } else if (e.key === "ArrowUp") {
                            e.preventDefault();
                            this.navigateOptions(-1);
                        }
                    });

                    // Sync if select changes programmatically
                    this.select.addEventListener("change", () => {
                        this.syncFromSelect();
                    });
                }

                toggle() {
                    this.isOpen ? this.close() : this.open();
                }

                open() {
                    this.isOpen = true;
                    this.wrapper.classList.add("open");
                }

                close() {
                    this.isOpen = false;
                    this.wrapper.classList.remove("open");
                }

                selectOption(index) {
                    // Update native select
                    this.select.selectedIndex = index;
                    this.select.dispatchEvent(
                        new Event("change", { bubbles: true }),
                    );

                    // Update display
                    this.syncFromSelect();
                    this.close();
                }

                syncFromSelect() {
                    const selectedOption =
                        this.select.options[this.select.selectedIndex];
                    if (selectedOption) {
                        this.trigger.querySelector(
                            ".custom-select-value",
                        ).textContent = selectedOption.text;

                        // Update selected class
                        this.optionsList
                            .querySelectorAll(".custom-select-option")
                            .forEach((opt, i) => {
                                opt.classList.toggle(
                                    "selected",
                                    i === this.select.selectedIndex,
                                );
                            });
                    }
                }

                navigateOptions(direction) {
                    if (!this.isOpen) {
                        this.open();
                        return;
                    }

                    let newIndex = this.select.selectedIndex + direction;
                    if (newIndex < 0) newIndex = this.select.options.length - 1;
                    if (newIndex >= this.select.options.length) newIndex = 0;

                    this.selectOption(newIndex);
                }

                // Rebuild options (e.g., if options change dynamically)
                refresh() {
                    this.optionsList.innerHTML = "";
                    Array.from(this.select.options).forEach((option, index) => {
                        const optionEl = document.createElement("div");
                        optionEl.className = "custom-select-option";
                        if (index === this.select.selectedIndex) {
                            optionEl.classList.add("selected");
                        }
                        optionEl.textContent = option.text;
                        optionEl.dataset.value = option.value;
                        optionEl.dataset.index = index;
                        this.optionsList.appendChild(optionEl);
                    });
                    this.syncFromSelect();
                }
            }

            // Initialize all custom selects
            function initCustomSelects() {
                document
                    .querySelectorAll("select:not(.custom-select select)")
                    .forEach((select) => {
                        new CustomSelect(select);
                    });
            }

            // ============================================================
            // SCALE MANAGER
            // ============================================================
            class ScaleManager {
                constructor() {
                    // Semitone intervals from root for each scale
                    this.scales = {
                        chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
                        major: [0, 2, 4, 5, 7, 9, 11],
                        minor: [0, 2, 3, 5, 7, 8, 10],
                        pentatonic: [0, 2, 4, 7, 9],
                        blues: [0, 3, 5, 6, 7, 10],
                        dorian: [0, 2, 3, 5, 7, 9, 10],
                        phrygian: [0, 1, 3, 5, 7, 8, 10],
                        lydian: [0, 2, 4, 6, 7, 9, 11],
                        mixolydian: [0, 2, 4, 5, 7, 9, 10],
                    };

                    // Note name to semitone offset from C
                    this.noteOffsets = {
                        C: 0,
                        "C#": 1,
                        D: 2,
                        "D#": 3,
                        E: 4,
                        F: 5,
                        "F#": 6,
                        G: 7,
                        "G#": 8,
                        A: 9,
                        "A#": 10,
                        B: 11,
                    };

                    this.rootNote = "C";
                    this.scaleType = "chromatic";
                }

                setRoot(note) {
                    this.rootNote = note;
                }

                setScale(scaleType) {
                    this.scaleType = scaleType;
                }

                /**
                 * Get all notes in scale across a given octave range
                 * Returns array of { note: 'C4', frequency: 261.63 }
                 */
                getNotesInRange(octaveLow, octaveHigh) {
                    const notes = [];
                    const rootOffset = this.noteOffsets[this.rootNote];
                    const intervals = this.scales[this.scaleType];
                    const noteNames = [
                        "C",
                        "C#",
                        "D",
                        "D#",
                        "E",
                        "F",
                        "F#",
                        "G",
                        "G#",
                        "A",
                        "A#",
                        "B",
                    ];

                    for (
                        let octave = octaveLow;
                        octave <= octaveHigh;
                        octave++
                    ) {
                        for (const interval of intervals) {
                            const semitone = rootOffset + interval;
                            const actualOctave =
                                octave + Math.floor(semitone / 12);
                            const noteIndex = semitone % 12;
                            const noteName = noteNames[noteIndex];
                            const midiNote = 12 + actualOctave * 12 + noteIndex;
                            const frequency =
                                440 * Math.pow(2, (midiNote - 69) / 12);

                            // Only include if within our octave range
                            if (
                                actualOctave >= octaveLow &&
                                actualOctave <= octaveHigh
                            ) {
                                notes.push({
                                    note: `${noteName}${actualOctave}`,
                                    frequency,
                                    midiNote,
                                });
                            }
                        }
                    }

                    // Remove duplicates and sort by frequency
                    const seen = new Set();
                    return notes
                        .filter((n) => {
                            if (seen.has(n.note)) return false;
                            seen.add(n.note);
                            return true;
                        })
                        .sort((a, b) => a.frequency - b.frequency);
                }

                /**
                 * Get notes for keyboard display (fixed keys, mapped to scale)
                 */
                getKeyboardNotes() {
                    const notes = this.getNotesInRange(4, 5);
                    // Return up to 11 notes for the keyboard keys
                    return notes.slice(0, 11);
                }
            }

            // ============================================================
            // GENERATIVE SEQUENCER
            // ============================================================
            class GenerativeSequencer {
                constructor(onNoteOn, onNoteOff) {
                    this.onNoteOn = onNoteOn;
                    this.onNoteOff = onNoteOff;
                    this.enabled = false;
                    this.bpm = 120;
                    this.probability = 0.7;
                    this.octaveLow = 4;
                    this.octaveHigh = 5;
                    this.noteLength = 1; // in beats
                    this.pattern = "random";

                    this.scaleManager = null;
                    this.currentNoteIndex = 0;
                    this.pendulumDirection = 1;
                    this.intervalId = null;
                    this.activeNote = null;
                }

                setScaleManager(scaleManager) {
                    this.scaleManager = scaleManager;
                }

                start() {
                    if (this.intervalId) return;
                    this.enabled = true;
                    this.scheduleNext();
                }

                stop() {
                    this.enabled = false;
                    if (this.intervalId) {
                        clearTimeout(this.intervalId);
                        this.intervalId = null;
                    }
                    if (this.activeNote) {
                        this.onNoteOff(this.activeNote.id);
                        this.activeNote = null;
                    }
                }

                scheduleNext() {
                    if (!this.enabled) return;

                    const beatDuration = 60000 / this.bpm;
                    const noteDuration = beatDuration * this.noteLength;

                    // Decide whether to play (probability check)
                    if (Math.random() < this.probability) {
                        this.playNote();
                    }

                    // Schedule next beat
                    this.intervalId = setTimeout(() => {
                        if (this.activeNote) {
                            this.onNoteOff(this.activeNote.id);
                            this.activeNote = null;
                        }
                        this.scheduleNext();
                    }, noteDuration);
                }

                playNote() {
                    if (!this.scaleManager) return;

                    const notes = this.scaleManager.getNotesInRange(
                        this.octaveLow,
                        this.octaveHigh,
                    );
                    if (notes.length === 0) return;

                    let note;
                    switch (this.pattern) {
                        case "random":
                            note =
                                notes[Math.floor(Math.random() * notes.length)];
                            break;
                        case "ascending":
                            note = notes[this.currentNoteIndex % notes.length];
                            this.currentNoteIndex++;
                            break;
                        case "descending":
                            note =
                                notes[
                                    notes.length -
                                        1 -
                                        (this.currentNoteIndex % notes.length)
                                ];
                            this.currentNoteIndex++;
                            break;
                        case "pendulum":
                            note = notes[this.currentNoteIndex];
                            this.currentNoteIndex += this.pendulumDirection;
                            if (this.currentNoteIndex >= notes.length - 1) {
                                this.pendulumDirection = -1;
                                this.currentNoteIndex = notes.length - 1;
                            } else if (this.currentNoteIndex <= 0) {
                                this.pendulumDirection = 1;
                                this.currentNoteIndex = 0;
                            }
                            break;
                    }

                    if (note) {
                        const id = `gen_${Date.now()}`;
                        this.activeNote = { id, note };
                        this.onNoteOn(id, note.frequency, 0.7);
                    }
                }

                setBPM(bpm) {
                    this.bpm = bpm;
                }

                setProbability(prob) {
                    this.probability = prob;
                }

                setOctaveRange(low, high) {
                    this.octaveLow = low;
                    this.octaveHigh = high;
                    this.currentNoteIndex = 0;
                }

                setNoteLength(beats) {
                    this.noteLength = beats;
                }

                setPattern(pattern) {
                    this.pattern = pattern;
                    this.currentNoteIndex = 0;
                    this.pendulumDirection = 1;
                }
            }

            // ============================================================
            // MODULATION SYSTEM (LFOs, S&H, Drift, MIDI)
            // ============================================================

            // Single LFO instance with independent rate
            class LFO {
                constructor() {
                    this.rate = 1; // Hz
                    this.phase = 0;
                }

                setRate(hz) {
                    this.rate = Math.max(0.1, hz);
                }

                // Returns 0-1 value based on current phase
                getValue() {
                    return (Math.sin(this.phase) + 1) / 2;
                }

                // Advance phase by deltaTime
                tick(deltaTime) {
                    this.phase += deltaTime * this.rate * Math.PI * 2;
                    if (this.phase > Math.PI * 2) this.phase -= Math.PI * 2;
                }
            }

            // Modulation manager - runs the animation loop and provides values
            class ModulationManager {
                constructor() {
                    this.lfo1 = new LFO();
                    this.lfo2 = new LFO();

                    // S&H state
                    this.snhRate = 1;
                    this.snhValue = 0.5;
                    this.snhLastTick = 0;

                    // Drift state
                    this.driftRate = 1;
                    this.driftValue = 0.5;
                    this.driftTarget = 0.5;
                    this.driftLastTick = 0;

                    // MIDI values
                    this.midiWheelValue = 0.5;
                    this.midiVelocityValue = 0.5;

                    // Animation
                    this.animationId = null;
                    this.lastTime = 0;
                    this.running = false;

                    // Registered destinations
                    this.destinations = [];
                }

                // Register a modulation destination
                addDestination(dest) {
                    this.destinations.push(dest);
                    this.checkRunning();
                }

                // Check if we need to run the animation loop
                checkRunning() {
                    const needsAnimation = this.destinations.some(
                        (d) =>
                            d.mode === "lfo1" ||
                            d.mode === "lfo2" ||
                            d.mode === "snh" ||
                            d.mode === "drift",
                    );

                    if (needsAnimation && !this.running) {
                        this.start();
                    } else if (!needsAnimation && this.running) {
                        this.stop();
                    }
                }

                start() {
                    if (this.running) return;
                    this.running = true;
                    this.lastTime = performance.now();
                    this.tick();
                }

                stop() {
                    this.running = false;
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                        this.animationId = null;
                    }
                }

                tick() {
                    if (!this.running) return;

                    const now = performance.now();
                    const deltaTime = (now - this.lastTime) / 1000;
                    this.lastTime = now;

                    // Update LFOs
                    this.lfo1.tick(deltaTime);
                    this.lfo2.tick(deltaTime);

                    // Update S&H
                    this.snhLastTick += deltaTime;
                    const snhInterval = 1 / this.snhRate;
                    if (this.snhLastTick >= snhInterval) {
                        this.snhLastTick = 0;
                        this.snhValue = Math.random();
                    }

                    // Update Drift
                    this.driftLastTick += deltaTime;
                    const driftInterval = 1 / this.driftRate;
                    if (this.driftLastTick >= driftInterval) {
                        this.driftLastTick = 0;
                        this.driftTarget = Math.random();
                    }
                    const smoothing =
                        1 - Math.exp(-deltaTime * this.driftRate * 3);
                    this.driftValue +=
                        (this.driftTarget - this.driftValue) * smoothing;

                    // Update all destinations
                    this.destinations.forEach((dest) => {
                        const rawValue = this.getRawValue(dest.mode);
                        if (rawValue !== null) {
                            dest.update(rawValue);
                        }
                    });

                    this.animationId = requestAnimationFrame(() => this.tick());
                }

                // Get raw 0-1 value for a modulation source
                getRawValue(mode) {
                    switch (mode) {
                        case "lfo1":
                            return this.lfo1.getValue();
                        case "lfo2":
                            return this.lfo2.getValue();
                        case "snh":
                            return this.snhValue;
                        case "drift":
                            return this.driftValue;
                        case "midi-wheel":
                            return this.midiWheelValue;
                        case "midi-velocity":
                            return this.midiVelocityValue;
                        default:
                            return null;
                    }
                }

                setLfo1Rate(hz) {
                    this.lfo1.setRate(hz);
                }

                setLfo2Rate(hz) {
                    this.lfo2.setRate(hz);
                }

                setSnhRate(hz) {
                    this.snhRate = Math.max(0.1, hz);
                }

                setDriftRate(hz) {
                    this.driftRate = Math.max(0.1, hz);
                }

                setMidiWheel(value) {
                    this.midiWheelValue = value;
                    // Immediately update destinations using midi-wheel
                    this.destinations.forEach((dest) => {
                        if (dest.mode === "midi-wheel") {
                            dest.update(value);
                        }
                    });
                }

                setMidiVelocity(velocity) {
                    this.midiVelocityValue = velocity;
                    // Immediately update destinations using midi-velocity
                    this.destinations.forEach((dest) => {
                        if (dest.mode === "midi-velocity") {
                            dest.update(velocity);
                        }
                    });
                }
            }

            // Modulation destination - wraps a parameter with range/offset
            class ModDestination {
                constructor(manager, onChange) {
                    this.manager = manager;
                    this.onChange = onChange;
                    this.mode = "manual";
                    this.range = 1;
                    this.offset = 0;
                    this.baseValue = 0.5;

                    manager.addDestination(this);
                }

                setMode(mode) {
                    this.mode = mode;
                    if (mode === "manual") {
                        this.onChange(this.baseValue);
                    }
                    this.manager.checkRunning();
                }

                setRange(range) {
                    this.range = Math.max(0.01, Math.min(1, range));
                }

                setOffset(offset) {
                    this.offset = Math.max(0, Math.min(1, offset));
                }

                setBaseValue(value) {
                    this.baseValue = value;
                    if (this.mode === "manual") {
                        this.onChange(value);
                    }
                }

                // Called by ModulationManager with raw 0-1 value
                // Offset: where sweep starts (floor)
                // Range: how far up from offset it sweeps
                update(rawValue) {
                    // rawValue is 0-1 from LFO sine wave
                    // Output = offset + (rawValue * range), clamped to 0-1
                    const output = this.offset + rawValue * this.range;
                    const clamped = Math.max(0, Math.min(1, output));
                    this.onChange(clamped);
                }

                getMode() {
                    return this.mode;
                }
            }

            // ============================================================
            // APPLICATION
            // ============================================================
            class App {
                constructor() {
                    this.terrain = new TerrainService();
                    this.search = new SearchService();
                    this.audio = new AudioEngine();
                    this.scaleManager = new ScaleManager();
                    this.midi = null;
                    this.waveformDisplay = null;
                    this.terrain3D = null;
                    this.map = null;
                    this.keyboard = null;
                    this.sequencer = null;

                    // Modulation system
                    this.modManager = null;
                    this.morphMod = null;
                    this.filterMod = null;

                    this.currentLocation = null;
                    this.wavetableData = null;
                    this.rawElevations = null; // Store raw data for intensity re-processing
                    this.terrainIntensity = 100;
                    this.isLightMode = window.matchMedia(
                        "(prefers-color-scheme: light)",
                    ).matches;
                    this.isLoading = false;
                }

                async initialize() {
                    // Apply initial theme based on system preference
                    if (this.isLightMode) {
                        document.body.classList.add("light-mode");
                    }

                    // Initialize 3D terrain display
                    this.terrain3D = new Terrain3DDisplay(
                        document.getElementById("terrain-canvas"),
                    );
                    this.terrain3D.setLightMode(this.isLightMode);

                    // Initialize waveform display
                    this.waveformDisplay = new WaveformDisplay(
                        document.getElementById("waveform-canvas"),
                    );
                    this.waveformDisplay.setLightMode(this.isLightMode);

                    // Initialize map
                    this.map = new MapController("map", (lat, lng) =>
                        this.onMapClick(lat, lng),
                    );
                    this.map.initialize();

                    // Initialize keyboard
                    this.keyboard = new KeyboardInput(
                        (id, freq, vel) => this.noteOn(id, freq, vel),
                        (id) => this.noteOff(id),
                    );
                    this.keyboard.enable();

                    // Initialize MIDI
                    this.midi = new MidiController(
                        (note, freq, vel) =>
                            this.noteOn(`midi_${note}`, freq, vel),
                        (note) => this.noteOff(`midi_${note}`),
                        (cc, value) => this.onMidiCC(cc, value),
                    );
                    await this.midi.initialize();

                    // Initialize generative sequencer
                    this.sequencer = new GenerativeSequencer(
                        (id, freq, vel) => this.noteOn(id, freq, vel),
                        (id) => this.noteOff(id),
                    );
                    this.sequencer.setScaleManager(this.scaleManager);

                    // Initialize modulation system
                    this.modManager = new ModulationManager();

                    // Morph modulation destination
                    this.morphMod = new ModDestination(
                        this.modManager,
                        (value) => {
                            this.setMorphPosition(value);
                            document.getElementById("morph-slider").value =
                                value;
                            document.getElementById("morph-value").textContent =
                                value.toFixed(2);
                        },
                    );

                    // Filter cutoff modulation destination
                    this.filterMod = new ModDestination(
                        this.modManager,
                        (value) => {
                            // value is 0-1, map linearly to filter frequency (20Hz - 20kHz)
                            const minFreq = 20;
                            const maxFreq = 20000;
                            const freq = minFreq + value * (maxFreq - minFreq);
                            this.audio.setFilterCutoff(freq);
                            // Update slider position
                            document.getElementById("filter-cutoff").value =
                                freq;
                            // Update display
                            const display =
                                freq >= 1000
                                    ? `${(freq / 1000).toFixed(1)}kHz`
                                    : `${Math.round(freq)}Hz`;
                            document.getElementById(
                                "filter-cutoff-value",
                            ).textContent = display;
                        },
                    );
                    this.filterMod.baseValue = 1; // Start fully open

                    // Initialize custom styled dropdowns
                    initCustomSelects();

                    // Bind UI controls
                    this.bindControls();

                    // Update keyboard with initial scale
                    this.updateKeyboard();

                    this.setStatus("Click map to load terrain");
                }

                bindControls() {
                    // Master volume
                    document
                        .getElementById("master-volume")
                        .addEventListener("input", (e) => {
                            this.audio.setMasterVolume(
                                parseFloat(e.target.value),
                            );
                        });

                    // Scale controls
                    document
                        .getElementById("root-note")
                        .addEventListener("change", (e) => {
                            this.scaleManager.setRoot(e.target.value);
                            this.updateKeyboard();
                        });
                    document
                        .getElementById("scale-type")
                        .addEventListener("change", (e) => {
                            this.scaleManager.setScale(e.target.value);
                            this.updateKeyboard();
                        });

                    // Morph slider
                    const morphSlider = document.getElementById("morph-slider");
                    const morphValue = document.getElementById("morph-value");
                    morphSlider.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        morphValue.textContent = value.toFixed(2);
                        this.morphMod.setBaseValue(value);
                    });

                    // Morph modulation source selector
                    document
                        .getElementById("morph-mod-source")
                        .addEventListener("change", (e) => {
                            this.morphMod.setMode(e.target.value);
                        });

                    // Morph modulation range and offset
                    const morphModRange =
                        document.getElementById("morph-mod-range");
                    morphModRange.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.morphMod.setRange(value);
                        e.target.dataset.tooltip = `Range: ${Math.round(value * 100)}%`;
                    });
                    morphModRange.dataset.tooltip = `Range: ${Math.round(morphModRange.value * 100)}%`;

                    const morphModOffset =
                        document.getElementById("morph-mod-offset");
                    morphModOffset.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.morphMod.setOffset(value);
                        e.target.dataset.tooltip = `Offset: ${Math.round(value * 100)}%`;
                    });
                    morphModOffset.dataset.tooltip = `Offset: ${Math.round(morphModOffset.value * 100)}%`;

                    // LFO rate controls (exponential: 0.05Hz - 10Hz)
                    const lfoSliderToHz = (value) => {
                        const minHz = 0.05;
                        const maxHz = 10;
                        return minHz * Math.pow(maxHz / minHz, value);
                    };

                    document
                        .getElementById("lfo1-rate")
                        .addEventListener("input", (e) => {
                            const hz = lfoSliderToHz(
                                parseFloat(e.target.value),
                            );
                            this.modManager.setLfo1Rate(hz);
                            document.getElementById(
                                "lfo1-rate-value",
                            ).textContent = hz.toFixed(hz < 1 ? 2 : 1);
                        });
                    document
                        .getElementById("lfo2-rate")
                        .addEventListener("input", (e) => {
                            const hz = lfoSliderToHz(
                                parseFloat(e.target.value),
                            );
                            this.modManager.setLfo2Rate(hz);
                            document.getElementById(
                                "lfo2-rate-value",
                            ).textContent = hz.toFixed(hz < 1 ? 2 : 1);
                        });

                    // Filter modulation source selector
                    document
                        .getElementById("filter-mod-source")
                        .addEventListener("change", (e) => {
                            this.filterMod.setMode(e.target.value);
                        });

                    // Filter modulation range
                    const filterModRange =
                        document.getElementById("filter-mod-range");
                    filterModRange.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.filterMod.setRange(value);
                        e.target.dataset.tooltip = `Range: ${Math.round(value * 100)}%`;
                    });
                    filterModRange.dataset.tooltip = `Range: ${Math.round(filterModRange.value * 100)}%`;

                    // Filter modulation offset
                    const filterModOffset =
                        document.getElementById("filter-mod-offset");
                    filterModOffset.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.filterMod.setOffset(value);
                        e.target.dataset.tooltip = `Offset: ${Math.round(value * 100)}%`;
                    });
                    filterModOffset.dataset.tooltip = `Offset: ${Math.round(filterModOffset.value * 100)}%`;

                    // Filter controls
                    const filterCutoff =
                        document.getElementById("filter-cutoff");
                    const filterCutoffValue = document.getElementById(
                        "filter-cutoff-value",
                    );
                    filterCutoff.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        // Convert linear slider to 0-1 for modulation base
                        const normalized =
                            Math.log(value / 20) / Math.log(20000 / 20);
                        this.filterMod.setBaseValue(normalized);
                        // If in manual mode, update directly
                        if (this.filterMod.getMode() === "manual") {
                            this.audio.setFilterCutoff(value);
                            filterCutoffValue.textContent =
                                value >= 1000
                                    ? `${(value / 1000).toFixed(1)}kHz`
                                    : `${Math.round(value)}Hz`;
                        }
                    });

                    const filterResonance =
                        document.getElementById("filter-resonance");
                    const filterResonanceValue = document.getElementById(
                        "filter-resonance-value",
                    );
                    filterResonance.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.audio.setFilterResonance(value);
                        filterResonanceValue.textContent = value.toFixed(1);
                    });

                    // Reverb controls
                    const reverbMix = document.getElementById("reverb-mix");
                    const reverbMixValue =
                        document.getElementById("reverb-mix-value");
                    reverbMix.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.audio.setReverbMix(value);
                        reverbMixValue.textContent = `${Math.round(value * 100)}%`;
                    });

                    const reverbDecay = document.getElementById("reverb-decay");
                    const reverbDecayValue =
                        document.getElementById("reverb-decay-value");
                    reverbDecay.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.audio.setReverbDecay(value);
                        reverbDecayValue.textContent = `${value.toFixed(1)}s`;
                    });

                    const reverbDamping =
                        document.getElementById("reverb-damping");
                    const reverbDampingValue = document.getElementById(
                        "reverb-damping-value",
                    );
                    reverbDamping.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.audio.setReverbDamping(value);
                        reverbDampingValue.textContent = `${Math.round(value * 100)}%`;
                    });

                    const reverbSize = document.getElementById("reverb-size");
                    const reverbSizeValue =
                        document.getElementById("reverb-size-value");
                    reverbSize.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.audio.setReverbSize(value);
                        reverbSizeValue.textContent = `${Math.round(value * 100)}%`;
                    });

                    const reverbPredelay =
                        document.getElementById("reverb-predelay");
                    const reverbPredelayValue = document.getElementById(
                        "reverb-predelay-value",
                    );
                    reverbPredelay.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.audio.setReverbPreDelay(value);
                        reverbPredelayValue.textContent = `${value}ms`;
                    });

                    const reverbShimmer =
                        document.getElementById("reverb-shimmer");
                    const reverbShimmerValue = document.getElementById(
                        "reverb-shimmer-value",
                    );
                    reverbShimmer.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.audio.setReverbShimmer(value);
                        reverbShimmerValue.textContent = `${Math.round(value * 100)}%`;
                    });

                    // Generative controls
                    document
                        .getElementById("gen-play-btn")
                        .addEventListener("click", () => {
                            const btn = document.getElementById("gen-play-btn");
                            const icon =
                                document.getElementById("gen-play-icon");
                            if (btn.classList.contains("playing")) {
                                // Stop
                                btn.classList.remove("playing");
                                icon.innerHTML =
                                    '<polygon points="5,3 19,12 5,21"/>';
                                this.sequencer.stop();
                            } else {
                                // Play
                                this.audio.initialize().then(() => {
                                    btn.classList.add("playing");
                                    icon.innerHTML =
                                        '<rect x="5" y="3" width="4" height="18"/><rect x="15" y="3" width="4" height="18"/>';
                                    this.sequencer.start();
                                });
                            }
                        });

                    const genBpm = document.getElementById("gen-bpm");
                    const genBpmValue =
                        document.getElementById("gen-bpm-value");
                    genBpm.addEventListener("input", (e) => {
                        const value = parseInt(e.target.value);
                        this.sequencer.setBPM(value);
                        genBpmValue.textContent = value;
                    });

                    const genProbability =
                        document.getElementById("gen-probability");
                    const genProbabilityValue = document.getElementById(
                        "gen-probability-value",
                    );
                    genProbability.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.sequencer.setProbability(value);
                        genProbabilityValue.textContent = `${Math.round(value * 100)}%`;
                    });

                    // Dual-range octave slider
                    const octaveLow = document.getElementById("gen-octave-low");
                    const octaveHigh =
                        document.getElementById("gen-octave-high");
                    const octaveRangeValue =
                        document.getElementById("octave-range-value");
                    const rangeSelected = document.querySelector(
                        "#octave-range .range-selected",
                    );

                    const updateOctaveRange = () => {
                        let low = parseInt(octaveLow.value);
                        let high = parseInt(octaveHigh.value);

                        // Ensure low <= high
                        if (low > high) {
                            [low, high] = [high, low];
                            octaveLow.value = low;
                            octaveHigh.value = high;
                        }

                        this.sequencer.setOctaveRange(low, high);
                        octaveRangeValue.textContent = `${low}-${high}`;

                        // Update visual range indicator
                        const min = 2,
                            max = 6;
                        const leftPercent = ((low - min) / (max - min)) * 100;
                        const rightPercent = ((high - min) / (max - min)) * 100;
                        rangeSelected.style.left = `${leftPercent}%`;
                        rangeSelected.style.width = `${rightPercent - leftPercent}%`;
                    };

                    octaveLow.addEventListener("input", updateOctaveRange);
                    octaveHigh.addEventListener("input", updateOctaveRange);
                    updateOctaveRange(); // Initialize

                    document
                        .getElementById("gen-length")
                        .addEventListener("change", (e) => {
                            this.sequencer.setNoteLength(
                                parseFloat(e.target.value),
                            );
                        });

                    document
                        .getElementById("gen-pattern")
                        .addEventListener("change", (e) => {
                            this.sequencer.setPattern(e.target.value);
                        });

                    // ADSR sliders
                    ["attack", "decay", "sustain", "release"].forEach(
                        (param) => {
                            const slider = document.getElementById(param);
                            const valueDisplay = document.getElementById(
                                `${param}-value`,
                            );

                            slider.addEventListener("input", (e) => {
                                const value = parseFloat(e.target.value);
                                const suffix = param === "sustain" ? "" : "s";
                                valueDisplay.textContent =
                                    value.toFixed(2) + suffix;
                                this.updateADSR();
                            });
                        },
                    );

                    // Theme toggle
                    document
                        .getElementById("theme-toggle")
                        .addEventListener("click", () => {
                            this.toggleTheme();
                        });

                    // Search
                    const searchInput = document.getElementById("search-input");
                    const searchBtn = document.getElementById("search-btn");

                    searchBtn.addEventListener("click", () =>
                        this.handleSearch(),
                    );
                    searchInput.addEventListener("keypress", (e) => {
                        if (e.key === "Enter") this.handleSearch();
                    });

                    // Reset view button
                    document
                        .getElementById("reset-view")
                        .addEventListener("click", () => {
                            this.terrain3D.resetView();
                        });

                    // Terrain intensity slider
                    const intensitySlider =
                        document.getElementById("terrain-intensity");
                    const intensityValue = document.getElementById(
                        "terrain-intensity-value",
                    );
                    intensitySlider.addEventListener("input", (e) => {
                        const value = parseInt(e.target.value);
                        intensityValue.textContent = `${value}%`;
                        this.terrainIntensity = value;
                        this.reprocessTerrain();
                    });

                    // My location button
                    document
                        .getElementById("location-btn")
                        .addEventListener("click", () => {
                            this.handleMyLocation();
                        });
                }

                updateKeyboard() {
                    const notes = this.scaleManager.getKeyboardNotes();
                    const keys = [
                        "a",
                        "s",
                        "d",
                        "f",
                        "g",
                        "h",
                        "j",
                        "k",
                        "l",
                        ";",
                        "'",
                    ];
                    const keyElements = document.querySelectorAll(".key");

                    keyElements.forEach((el, i) => {
                        if (i < notes.length) {
                            const note = notes[i];
                            el.dataset.freq = note.frequency;
                            el.dataset.note = note.note;
                            el.querySelector(".key-note").textContent =
                                note.note;
                            el.style.display = "";
                        } else {
                            // Hide keys that don't have notes in this scale
                            el.style.display = "none";
                        }
                    });

                    // Update keyboard input mapping
                    if (this.keyboard) {
                        this.keyboard.keyMap.clear();
                        keyElements.forEach((el, i) => {
                            if (i < notes.length) {
                                const key = keys[i];
                                this.keyboard.keyMap.set(key, {
                                    element: el,
                                    frequency: notes[i].frequency,
                                });
                            }
                        });
                    }
                }

                toggleTheme() {
                    this.isLightMode = !this.isLightMode;
                    document.body.classList.toggle(
                        "light-mode",
                        this.isLightMode,
                    );
                    document.getElementById("theme-toggle").textContent = this
                        .isLightMode
                        ? "Dark"
                        : "Light";

                    this.terrain3D.setLightMode(this.isLightMode);
                    this.waveformDisplay.setLightMode(this.isLightMode);
                }

                async handleSearch() {
                    const query = document
                        .getElementById("search-input")
                        .value.trim();
                    if (!query) return;

                    this.setStatus("Searching...", "loading");

                    try {
                        const result = await this.search.search(query);
                        this.setStatus(`Found: ${result.name}`);
                        this.map.goTo(result.lat, result.lng);
                    } catch (error) {
                        this.setStatus(
                            "Search failed: " + error.message,
                            "error",
                        );
                    }
                }

                handleMyLocation() {
                    if (!navigator.geolocation) {
                        this.setStatus("Geolocation not supported", "error");
                        return;
                    }

                    const btn = document.getElementById("location-btn");
                    btn.classList.add("locating");
                    this.setStatus("Finding your location...", "loading");

                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            btn.classList.remove("locating");
                            const { latitude, longitude } = position.coords;
                            this.setStatus(`Found: Your location`);
                            this.map.goTo(latitude, longitude, 12);
                        },
                        (error) => {
                            btn.classList.remove("locating");
                            let message = "Location error";
                            switch (error.code) {
                                case error.PERMISSION_DENIED:
                                    message = "Location permission denied";
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    message = "Location unavailable";
                                    break;
                                case error.TIMEOUT:
                                    message = "Location request timed out";
                                    break;
                            }
                            this.setStatus(message, "error");
                        },
                        { enableHighAccuracy: true, timeout: 10000 },
                    );
                }

                reprocessTerrain() {
                    if (!this.rawElevations) {
                        return; // No terrain loaded yet
                    }

                    // Re-normalize with new intensity
                    const result = this.terrain.normalizeToWavetable(
                        this.rawElevations,
                        this.terrainIntensity,
                    );

                    this.wavetableData = result;

                    // Update audio engine
                    this.audio.loadWavetable(result.frames);

                    // Update visualizations (preserve camera angle)
                    this.waveformDisplay.setFrames(result.frames);
                    this.terrain3D.setFrames(result.frames, false);

                    console.log(
                        `Reprocessed terrain at ${this.terrainIntensity}% intensity`,
                    );
                }

                updateADSR() {
                    this.audio.setADSR(
                        parseFloat(document.getElementById("attack").value),
                        parseFloat(document.getElementById("decay").value),
                        parseFloat(document.getElementById("sustain").value),
                        parseFloat(document.getElementById("release").value),
                    );
                }

                async onMapClick(lat, lng) {
                    // Prevent double-loading
                    if (this.isLoading) {
                        console.log("Already loading, ignoring click");
                        return;
                    }

                    // Initialize audio on first interaction
                    await this.audio.initialize();

                    // Update grid size from dropdown
                    const areaSize = parseFloat(
                        document.getElementById("area-size").value,
                    );
                    CONFIG.wavetable.gridSizeKm = areaSize;

                    this.currentLocation = { lat, lng };
                    document.getElementById("location-display").textContent =
                        `${lat.toFixed(4)}, ${lng.toFixed(4)} (${areaSize}km)`;

                    // Show loading
                    this.isLoading = true;
                    document
                        .getElementById("map-loading")
                        .classList.remove("hidden");

                    try {
                        // Fetch terrain
                        console.log(
                            `Fetching terrain for ${lat}, ${lng} at ${areaSize}km...`,
                        );
                        this.wavetableData = await this.terrain.fetchElevation(
                            lat,
                            lng,
                        );
                        console.log(
                            "Terrain data received:",
                            this.wavetableData,
                        );

                        // Store raw elevations for intensity re-processing
                        this.rawElevations = this.wavetableData.rawElevations;

                        // Load into audio engine
                        this.audio.loadWavetable(this.wavetableData.frames);

                        // Update visualizations
                        console.log("Updating visualizations...");
                        this.waveformDisplay.setFrames(
                            this.wavetableData.frames,
                        );
                        this.terrain3D.setFrames(this.wavetableData.frames);

                        // Hide empty state
                        document
                            .getElementById("terrain-empty")
                            .classList.add("hidden");

                        // Update status
                        const { globalMin, globalMax } =
                            this.wavetableData.metadata;
                        this.setStatus(
                            `Terrain loaded: ${Math.round(globalMin)}m - ${Math.round(globalMax)}m`,
                        );
                    } catch (error) {
                        console.error("Failed to load terrain:", error);
                        this.setStatus(
                            "Failed to load terrain: " + error.message,
                            "error",
                        );
                    } finally {
                        this.isLoading = false;
                        document
                            .getElementById("map-loading")
                            .classList.add("hidden");
                    }
                }

                noteOn(noteId, frequency, velocity) {
                    // Update modulation system with velocity
                    this.modManager.setMidiVelocity(velocity);
                    this.audio.noteOn(noteId, frequency, velocity);
                }

                noteOff(noteId) {
                    this.audio.noteOff(noteId);
                }

                setMorphPosition(position) {
                    this.audio.setMorphPosition(position);
                    this.waveformDisplay.setMorphPosition(position);
                    this.terrain3D.setMorphPosition(position);
                }

                onMidiCC(cc, value) {
                    // CC1 = Mod wheel
                    if (cc === 1) {
                        this.modManager.setMidiWheel(value);
                    }
                }

                setStatus(message, type = "info") {
                    document.getElementById("status-message").textContent =
                        message;
                }

                setMidiStatus(connected, deviceName) {
                    const indicator = document.getElementById("midi-indicator");
                    const status = document.getElementById("midi-status");

                    if (connected) {
                        indicator.classList.add("connected");
                        status.textContent = deviceName;
                    } else {
                        indicator.classList.remove("connected");
                        status.textContent = deviceName;
                    }
                }
            }

            // ============================================================
            // INITIALIZATION
            // ============================================================
            const app = new App();
            document.addEventListener("DOMContentLoaded", () =>
                app.initialize(),
            );
        </script>
    </body>
</html>
