<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Carta — Terrain Wavetable Synth</title>
        <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        />
        <style>
            /* ============================================================
           CSS RESET & VARIABLES
           ============================================================ */
            *,
            *::before,
            *::after {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            :root {
                --bg: #000000;
                --surface: #0a0a0a;
                --border: #222222;
                --text: #ffffff;
                --text-muted: #666666;
                --accent: #ffffff;
                --font-mono:
                    "SF Mono", "Monaco", "Inconsolata", "Fira Code", monospace;
            }

            /* Light mode */
            .light-mode {
                --bg: #ffffff;
                --surface: #f5f5f5;
                --border: #dddddd;
                --text: #000000;
                --text-muted: #888888;
                --accent: #000000;
            }

            /* ============================================================
           BASE STYLES
           ============================================================ */
            html,
            body {
                height: 100%;
                background: var(--bg);
                color: var(--text);
                font-family: var(--font-mono);
                font-size: 12px;
                line-height: 1.4;
                transition:
                    background 0.2s,
                    color 0.2s;
            }

            /* ============================================================
           APP LAYOUT
           ============================================================ */
            #app {
                display: flex;
                flex-direction: column;
                height: 100vh;
                max-width: 1400px;
                margin: 0 auto;
                padding: 16px;
                gap: 8px;
                overflow-y: auto;
            }

            main {
                flex: 1;
                min-height: 300px;
            }

            /* ============================================================
           HEADER
           ============================================================ */
            header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding-bottom: 12px;
                border-bottom: 1px solid var(--border);
            }

            h1 {
                font-size: 14px;
                font-weight: 400;
                letter-spacing: 0.2em;
                text-transform: uppercase;
            }

            .header-controls {
                display: flex;
                align-items: center;
                gap: 16px;
            }

            .control-group {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .control-group label {
                color: var(--text-muted);
                font-size: 10px;
                text-transform: uppercase;
                letter-spacing: 0.1em;
            }

            /* Theme toggle button */
            .theme-toggle {
                background: none;
                border: 1px solid var(--border);
                color: var(--text);
                padding: 4px 8px;
                font-family: inherit;
                font-size: 10px;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                transition: border-color 0.2s;
            }

            .theme-toggle:hover {
                border-color: var(--text);
            }

            /* ============================================================
           MAIN CONTENT AREA
           ============================================================ */
            main {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 12px;
                min-height: 0;
            }

            /* ============================================================
           MAP SECTION
           ============================================================ */
            #map-section {
                background: var(--surface);
                border: 1px solid var(--border);
                position: relative;
                min-height: 300px;
                display: flex;
                flex-direction: column;
            }

            /* Search bar */
            .map-search {
                display: flex;
                gap: 8px;
                padding: 8px;
                background: var(--bg);
                border-bottom: 1px solid var(--border);
            }

            .map-search input {
                flex: 1;
                background: var(--surface);
                border: 1px solid var(--border);
                color: var(--text);
                padding: 6px 10px;
                font-family: inherit;
                font-size: 11px;
            }

            .map-search input::placeholder {
                color: var(--text-muted);
            }

            .map-search input:focus {
                outline: none;
                border-color: var(--text-muted);
            }

            .map-search button {
                background: var(--surface);
                border: 1px solid var(--border);
                color: var(--text);
                padding: 6px 12px;
                font-family: inherit;
                font-size: 10px;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }

            .map-search button:hover {
                border-color: var(--text);
            }

            .map-search .location-btn {
                padding: 6px 8px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .map-search .location-btn svg {
                width: 14px;
                height: 14px;
            }

            .map-search .location-btn.locating {
                animation: pulse 1s ease-in-out infinite;
            }

            @keyframes pulse {
                0%,
                100% {
                    opacity: 1;
                }
                50% {
                    opacity: 0.5;
                }
            }

            #map {
                flex: 1;
                min-height: 0;
            }

            /* Override Leaflet styles for dark theme */
            .leaflet-container {
                background: var(--bg);
            }

            .leaflet-tile-pane {
                filter: grayscale(100%) invert(100%) contrast(0.9);
            }

            .light-mode .leaflet-tile-pane {
                filter: grayscale(100%) contrast(1.1);
            }

            .map-info {
                position: absolute;
                bottom: 8px;
                left: 8px;
                z-index: 1000;
                background: rgba(0, 0, 0, 0.8);
                padding: 6px 10px;
                font-size: 10px;
                color: var(--text-muted);
                border: 1px solid var(--border);
            }

            .light-mode .map-info {
                background: rgba(255, 255, 255, 0.9);
            }

            /* ============================================================
           VISUALIZATION SECTION
           ============================================================ */
            #visualization {
                position: relative;
                min-height: 0;
            }

            .viz-panel {
                background: var(--surface);
                border: 1px solid var(--border);
                position: relative;
                overflow: hidden;
            }

            .viz-panel canvas {
                width: 100%;
                height: 100%;
                display: block;
            }

            /* Terrain panel fills the entire visualization area */
            #terrain-panel {
                position: absolute;
                inset: 0;
            }

            /* Waveform panel inset in bottom-right corner */
            #waveform-panel {
                position: absolute;
                bottom: 12px;
                right: 12px;
                width: 150px;
                height: 80px;
                z-index: 10;
                background: rgba(10, 10, 10, 0.85);
                border: 1px solid var(--border);
            }

            .light-mode #waveform-panel {
                background: rgba(245, 245, 245, 0.9);
            }

            .viz-label {
                position: absolute;
                top: 8px;
                left: 8px;
                font-size: 10px;
                color: var(--text-muted);
                text-transform: uppercase;
                letter-spacing: 0.1em;
                z-index: 10;
                pointer-events: none;
            }

            /* 3D terrain controls */
            .terrain-controls {
                position: absolute;
                top: 8px;
                right: 8px;
                display: flex;
                gap: 4px;
                z-index: 10;
            }

            .terrain-controls button {
                background: var(--bg);
                border: 1px solid var(--border);
                color: var(--text-muted);
                width: 24px;
                height: 24px;
                font-size: 12px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .terrain-controls button:hover {
                color: var(--text);
                border-color: var(--text);
            }

            /* ============================================================
           CONTROLS SECTION
           ============================================================ */
            #controls {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            /* Scale controls row */
            #scale-controls {
                display: flex;
                gap: 12px;
                padding: 12px;
                background: var(--surface);
                border: 1px solid var(--border);
            }

            #scale-controls .control-group {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            #scale-controls label {
                font-size: 10px;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                color: var(--text-muted);
                white-space: nowrap;
            }

            #scale-controls select {
                font-size: 11px;
            }

            /* Morph slider */
            #morph-control {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 12px;
                background: var(--surface);
                border: 1px solid var(--border);
            }

            #morph-control label {
                font-size: 10px;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                color: var(--text-muted);
                white-space: nowrap;
            }

            #morph-control input[type="range"] {
                flex: 1;
            }

            #morph-control .morph-value {
                font-size: 10px;
                color: var(--text-muted);
                min-width: 40px;
                text-align: right;
            }

            /* Morph modulation section */
            #morph-control .mod-section {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-left: 12px;
                padding-left: 12px;
                border-left: 1px solid var(--border);
            }

            #morph-control .mod-section label {
                font-size: 10px;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                color: var(--text-muted);
            }

            #morph-control .mod-rate {
                width: 60px;
            }

            #morph-control .mod-rate-value {
                font-size: 10px;
                color: var(--text-muted);
                min-width: 30px;
            }

            #morph-control .mod-range-group {
                display: flex;
                align-items: center;
                gap: 4px;
            }

            #morph-control .mod-range-group label {
                font-size: 9px;
                text-transform: uppercase;
                color: var(--text-muted);
            }

            #morph-control .mod-range-group input[type="range"] {
                width: 50px;
            }

            /* Filter, Reverb & Generative controls - single row */
            #fx-controls {
                display: flex;
                gap: 12px;
                padding: 12px;
                background: var(--surface);
                border: 1px solid var(--border);
                flex-wrap: wrap;
            }

            .fx-section {
                display: flex;
                align-items: center;
                gap: 12px;
                padding-right: 16px;
                border-right: 1px solid var(--border);
            }

            .fx-section:last-child {
                border-right: none;
                padding-right: 0;
            }

            .fx-section .section-title {
                font-size: 10px;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                color: var(--text-muted);
                white-space: nowrap;
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .fx-section .section-title input[type="checkbox"] {
                accent-color: var(--text);
            }

            .play-btn {
                background: none;
                border: 1px solid var(--border);
                color: var(--text);
                width: 24px;
                height: 24px;
                padding: 4px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 2px;
            }

            .play-btn:hover {
                border-color: var(--text);
            }

            .play-btn.playing {
                background: var(--text);
                color: var(--bg);
            }

            .play-btn svg {
                width: 12px;
                height: 12px;
            }

            .fx-param {
                display: flex;
                flex-direction: column;
                gap: 2px;
                min-width: 60px;
            }

            .fx-param label {
                font-size: 9px;
                text-transform: uppercase;
                letter-spacing: 0.05em;
                color: var(--text-muted);
            }

            .fx-param .value {
                font-size: 9px;
                color: var(--text);
            }

            .fx-param input[type="range"] {
                width: 60px;
            }

            /* ADSR controls */
            #adsr-controls {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 12px;
            }

            .adsr-param {
                display: flex;
                flex-direction: column;
                gap: 6px;
                padding: 12px;
                background: var(--surface);
                border: 1px solid var(--border);
            }

            .adsr-param label {
                font-size: 10px;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                color: var(--text-muted);
            }

            .adsr-param .value {
                font-size: 10px;
                color: var(--text);
            }

            /* ============================================================
           RANGE INPUT STYLING
           ============================================================ */
            input[type="range"] {
                -webkit-appearance: none;
                appearance: none;
                background: transparent;
                cursor: pointer;
                height: 20px;
            }

            input[type="range"]::-webkit-slider-runnable-track {
                height: 2px;
                background: var(--border);
            }

            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 12px;
                height: 12px;
                background: var(--text);
                border-radius: 50%;
                margin-top: -5px;
            }

            input[type="range"]::-moz-range-track {
                height: 2px;
                background: var(--border);
            }

            input[type="range"]::-moz-range-thumb {
                width: 12px;
                height: 12px;
                background: var(--text);
                border: none;
                border-radius: 50%;
            }

            /* ============================================================
           SELECT/DROPDOWN STYLING
           ============================================================ */
            select {
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                background-color: var(--bg);
                border: 1px solid var(--border);
                color: var(--text);
                padding: 4px 24px 4px 8px;
                font-family: var(--font-mono);
                font-size: 10px;
                cursor: pointer;
                border-radius: 0;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 8 8'%3E%3Cpath fill='%23666' d='M0 2l4 4 4-4z'/%3E%3C/svg%3E");
                background-repeat: no-repeat;
                background-position: right 8px center;
                background-size: 8px;
            }

            .light-mode select {
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 8 8'%3E%3Cpath fill='%23888' d='M0 2l4 4 4-4z'/%3E%3C/svg%3E");
            }

            select:hover {
                border-color: var(--text-muted);
            }

            select:focus {
                outline: none;
                border-color: var(--text);
            }

            select option {
                background: var(--bg);
                color: var(--text);
                padding: 4px 8px;
            }

            /* ============================================================
           KEYBOARD SECTION
           ============================================================ */
            #keyboard {
                padding: 16px;
                background: var(--surface);
                border: 1px solid var(--border);
            }

            .keyboard-row {
                display: flex;
                justify-content: center;
                gap: 4px;
            }

            .key {
                width: 48px;
                height: 64px;
                background: var(--bg);
                border: 1px solid var(--border);
                display: flex;
                flex-direction: column;
                justify-content: flex-end;
                align-items: center;
                padding-bottom: 8px;
                cursor: pointer;
                user-select: none;
                transition:
                    background 0.05s,
                    border-color 0.05s;
            }

            .key:hover {
                border-color: var(--text-muted);
            }

            .key.active {
                background: var(--text);
                border-color: var(--text);
            }

            .key.active .key-label,
            .key.active .key-note {
                color: var(--bg);
            }

            .key-label {
                font-size: 10px;
                color: var(--text-muted);
            }

            .key-note {
                font-size: 9px;
                color: var(--text-muted);
                margin-top: 2px;
            }

            /* ============================================================
           STATUS BAR
           ============================================================ */
            #status {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
                background: var(--surface);
                border: 1px solid var(--border);
                font-size: 10px;
                color: var(--text-muted);
            }

            #status .midi-status {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .midi-indicator {
                width: 6px;
                height: 6px;
                border-radius: 50%;
                background: var(--text-muted);
            }

            .midi-indicator.connected {
                background: #00cc00;
            }

            .light-mode .midi-indicator.connected {
                background: #009900;
            }

            /* ============================================================
           LOADING STATE
           ============================================================ */
            .loading-overlay {
                position: absolute;
                inset: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 2000;
            }

            .light-mode .loading-overlay {
                background: rgba(255, 255, 255, 0.8);
            }

            .loading-overlay.hidden {
                display: none;
            }

            .spinner {
                width: 24px;
                height: 24px;
                border: 2px solid var(--border);
                border-top-color: var(--text);
                border-radius: 50%;
                animation: spin 0.8s linear infinite;
            }

            @keyframes spin {
                to {
                    transform: rotate(360deg);
                }
            }

            /* ============================================================
           UTILITY CLASSES
           ============================================================ */
            .hidden {
                display: none !important;
            }
        </style>
    </head>
    <body>
        <div id="app">
            <!-- Header -->
            <header>
                <h1>Carta</h1>
                <div class="header-controls">
                    <div class="control-group">
                        <label for="master-volume">Vol</label>
                        <input
                            type="range"
                            id="master-volume"
                            min="0"
                            max="1"
                            step="0.01"
                            value="0.7"
                        />
                    </div>
                    <button class="theme-toggle" id="theme-toggle">
                        Light
                    </button>
                </div>
            </header>

            <!-- Main content: Map + Visualizations -->
            <main>
                <section id="map-section">
                    <div class="map-search">
                        <input
                            type="text"
                            id="search-input"
                            placeholder="Search location or coords (lat, lng)"
                        />
                        <button id="search-btn">Go</button>
                        <button
                            id="location-btn"
                            class="location-btn"
                            title="Use my location"
                        >
                            <svg
                                viewBox="0 0 24 24"
                                fill="none"
                                stroke="currentColor"
                                stroke-width="2"
                                stroke-linecap="round"
                                stroke-linejoin="round"
                            >
                                <circle cx="12" cy="12" r="3" />
                                <path d="M12 2v4M12 18v4M2 12h4M18 12h4" />
                            </svg>
                        </button>
                    </div>
                    <div id="map"></div>
                    <div class="map-info">
                        <span id="location-display"
                            >Click map to select terrain</span
                        >
                    </div>
                    <div id="map-loading" class="loading-overlay hidden">
                        <div class="spinner"></div>
                    </div>
                </section>

                <section id="visualization">
                    <div class="viz-panel" id="terrain-panel">
                        <span class="viz-label">Terrain</span>
                        <canvas id="terrain-canvas"></canvas>
                        <div class="terrain-controls">
                            <button id="reset-view" title="Reset camera view">
                                <svg
                                    width="14"
                                    height="14"
                                    viewBox="0 0 24 24"
                                    fill="none"
                                    stroke="currentColor"
                                    stroke-width="2"
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                >
                                    <path
                                        d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
                                    />
                                    <path d="M3 3v5h5" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="viz-panel" id="waveform-panel">
                        <span class="viz-label">Waveform</span>
                        <canvas id="waveform-canvas"></canvas>
                    </div>
                </section>
            </main>

            <!-- Scale controls -->
            <div id="scale-controls">
                <div class="control-group">
                    <label for="root-note">Root</label>
                    <select id="root-note">
                        <option value="C">C</option>
                        <option value="C#">C#</option>
                        <option value="D">D</option>
                        <option value="D#">D#</option>
                        <option value="E">E</option>
                        <option value="F">F</option>
                        <option value="F#">F#</option>
                        <option value="G">G</option>
                        <option value="G#">G#</option>
                        <option value="A">A</option>
                        <option value="A#">A#</option>
                        <option value="B">B</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="scale-type">Scale</label>
                    <select id="scale-type">
                        <option value="chromatic">Chromatic</option>
                        <option value="major">Major</option>
                        <option value="minor">Minor</option>
                        <option value="pentatonic">Pentatonic</option>
                        <option value="blues">Blues</option>
                        <option value="dorian">Dorian</option>
                        <option value="phrygian">Phrygian</option>
                        <option value="lydian">Lydian</option>
                        <option value="mixolydian">Mixolydian</option>
                    </select>
                </div>
            </div>

            <!-- Morph control -->
            <div id="morph-control">
                <label for="morph-slider">Morph N↔S</label>
                <input
                    type="range"
                    id="morph-slider"
                    min="0"
                    max="1"
                    step="0.001"
                    value="0.5"
                />
                <span class="morph-value" id="morph-value">0.50</span>
                <div class="mod-section">
                    <label for="morph-mod-source">Mod</label>
                    <select id="morph-mod-source">
                        <option value="manual">Manual</option>
                        <option value="lfo">LFO</option>
                        <option value="snh">S&H</option>
                        <option value="drift">Drift</option>
                        <option value="midi-wheel">MW</option>
                        <option value="midi-velocity">Vel</option>
                    </select>
                    <input
                        type="range"
                        id="morph-mod-rate"
                        class="mod-rate"
                        min="0.1"
                        max="10"
                        step="0.1"
                        value="1"
                        title="Modulation Rate (Hz)"
                    />
                    <span class="mod-rate-value" id="morph-mod-rate-value"
                        >1.0</span
                    >
                    <div class="mod-range-group">
                        <label>Rng</label>
                        <input
                            type="range"
                            id="morph-mod-range"
                            min="0.01"
                            max="1"
                            step="0.01"
                            value="1"
                            title="Modulation Range"
                        />
                    </div>
                    <div class="mod-range-group">
                        <label>Ofs</label>
                        <input
                            type="range"
                            id="morph-mod-offset"
                            min="0"
                            max="1"
                            step="0.01"
                            value="0"
                            title="Modulation Offset"
                        />
                    </div>
                </div>
            </div>

            <!-- Filter, Reverb & Autoplay -->
            <div id="fx-controls">
                <div class="fx-section">
                    <span class="section-title">Filter</span>
                    <div class="fx-param">
                        <label>Cut</label>
                        <input
                            type="range"
                            id="filter-cutoff"
                            min="20"
                            max="20000"
                            step="1"
                            value="20000"
                        />
                        <span class="value" id="filter-cutoff-value"
                            >20kHz</span
                        >
                    </div>
                    <div class="fx-param">
                        <label>Res</label>
                        <input
                            type="range"
                            id="filter-resonance"
                            min="0"
                            max="20"
                            step="0.1"
                            value="0"
                        />
                        <span class="value" id="filter-resonance-value"
                            >0.0</span
                        >
                    </div>
                </div>
                <div class="fx-section">
                    <span class="section-title">Reverb</span>
                    <div class="fx-param">
                        <label>Mix</label>
                        <input
                            type="range"
                            id="reverb-mix"
                            min="0"
                            max="1"
                            step="0.01"
                            value="0"
                        />
                        <span class="value" id="reverb-mix-value">0%</span>
                    </div>
                    <div class="fx-param">
                        <label>Decay</label>
                        <input
                            type="range"
                            id="reverb-decay"
                            min="0.1"
                            max="5"
                            step="0.1"
                            value="2"
                        />
                        <span class="value" id="reverb-decay-value">2.0s</span>
                    </div>
                </div>
                <div class="fx-section">
                    <div class="section-title">
                        <button
                            id="gen-play-btn"
                            class="play-btn"
                            title="Play/Pause"
                        >
                            <svg
                                id="gen-play-icon"
                                viewBox="0 0 24 24"
                                fill="currentColor"
                            >
                                <polygon points="5,3 19,12 5,21" />
                            </svg>
                        </button>
                    </div>
                    <div class="fx-param">
                        <label>BPM</label>
                        <input
                            type="range"
                            id="gen-bpm"
                            min="30"
                            max="240"
                            step="1"
                            value="120"
                        />
                        <span class="value" id="gen-bpm-value">120</span>
                    </div>
                    <div class="fx-param">
                        <label>Prob</label>
                        <input
                            type="range"
                            id="gen-probability"
                            min="0"
                            max="1"
                            step="0.05"
                            value="0.7"
                        />
                        <span class="value" id="gen-probability-value"
                            >70%</span
                        >
                    </div>
                    <div class="fx-param">
                        <label>Oct</label>
                        <select id="gen-octave-low">
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4" selected>4</option>
                            <option value="5">5</option>
                        </select>
                    </div>
                    <div class="fx-param">
                        <label>-</label>
                        <select id="gen-octave-high">
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5" selected>5</option>
                            <option value="6">6</option>
                        </select>
                    </div>
                    <div class="fx-param">
                        <label>Len</label>
                        <select id="gen-length">
                            <option value="0.25">1/16</option>
                            <option value="0.5">1/8</option>
                            <option value="1" selected>1/4</option>
                            <option value="2">1/2</option>
                            <option value="4">1</option>
                        </select>
                    </div>
                    <div class="fx-param">
                        <label>Pat</label>
                        <select id="gen-pattern">
                            <option value="random">Rnd</option>
                            <option value="ascending">Up</option>
                            <option value="descending">Dn</option>
                            <option value="pendulum">Pnd</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- ADSR controls -->
            <div id="adsr-controls">
                <div class="adsr-param">
                    <label for="attack">Attack</label>
                    <input
                        type="range"
                        id="attack"
                        min="0.001"
                        max="2"
                        step="0.001"
                        value="0.01"
                    />
                    <span class="value" id="attack-value">0.01s</span>
                </div>
                <div class="adsr-param">
                    <label for="decay">Decay</label>
                    <input
                        type="range"
                        id="decay"
                        min="0.001"
                        max="2"
                        step="0.001"
                        value="0.1"
                    />
                    <span class="value" id="decay-value">0.10s</span>
                </div>
                <div class="adsr-param">
                    <label for="sustain">Sustain</label>
                    <input
                        type="range"
                        id="sustain"
                        min="0"
                        max="1"
                        step="0.01"
                        value="0.7"
                    />
                    <span class="value" id="sustain-value">0.70</span>
                </div>
                <div class="adsr-param">
                    <label for="release">Release</label>
                    <input
                        type="range"
                        id="release"
                        min="0.001"
                        max="3"
                        step="0.001"
                        value="0.3"
                    />
                    <span class="value" id="release-value">0.30s</span>
                </div>
            </div>

            <!-- On-screen keyboard -->
            <section id="keyboard">
                <div class="keyboard-row">
                    <div
                        class="key"
                        data-key="a"
                        data-note="C4"
                        data-freq="261.63"
                    >
                        <span class="key-label">A</span>
                        <span class="key-note">C4</span>
                    </div>
                    <div
                        class="key"
                        data-key="s"
                        data-note="D4"
                        data-freq="293.66"
                    >
                        <span class="key-label">S</span>
                        <span class="key-note">D4</span>
                    </div>
                    <div
                        class="key"
                        data-key="d"
                        data-note="E4"
                        data-freq="329.63"
                    >
                        <span class="key-label">D</span>
                        <span class="key-note">E4</span>
                    </div>
                    <div
                        class="key"
                        data-key="f"
                        data-note="F4"
                        data-freq="349.23"
                    >
                        <span class="key-label">F</span>
                        <span class="key-note">F4</span>
                    </div>
                    <div
                        class="key"
                        data-key="g"
                        data-note="G4"
                        data-freq="392.00"
                    >
                        <span class="key-label">G</span>
                        <span class="key-note">G4</span>
                    </div>
                    <div
                        class="key"
                        data-key="h"
                        data-note="A4"
                        data-freq="440.00"
                    >
                        <span class="key-label">H</span>
                        <span class="key-note">A4</span>
                    </div>
                    <div
                        class="key"
                        data-key="j"
                        data-note="B4"
                        data-freq="493.88"
                    >
                        <span class="key-label">J</span>
                        <span class="key-note">B4</span>
                    </div>
                    <div
                        class="key"
                        data-key="k"
                        data-note="C5"
                        data-freq="523.25"
                    >
                        <span class="key-label">K</span>
                        <span class="key-note">C5</span>
                    </div>
                    <div
                        class="key"
                        data-key="l"
                        data-note="D5"
                        data-freq="587.33"
                    >
                        <span class="key-label">L</span>
                        <span class="key-note">D5</span>
                    </div>
                    <div
                        class="key"
                        data-key=";"
                        data-note="E5"
                        data-freq="659.25"
                    >
                        <span class="key-label">;</span>
                        <span class="key-note">E5</span>
                    </div>
                    <div
                        class="key"
                        data-key="'"
                        data-note="F5"
                        data-freq="698.46"
                    >
                        <span class="key-label">'</span>
                        <span class="key-note">F5</span>
                    </div>
                </div>
            </section>

            <!-- Status bar -->
            <footer id="status">
                <span id="status-message">Click map to load terrain</span>
                <div class="midi-status">
                    <span class="midi-indicator" id="midi-indicator"></span>
                    <span id="midi-status">No MIDI</span>
                </div>
            </footer>
        </div>

        <!-- External libraries -->
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

        <script>
            // OrbitControls inline (since CDN version has module issues)
            // Simplified orbit controls for terrain viewing
            THREE.OrbitControls = function (camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.enabled = true;
                this.enableDamping = false;
                this.dampingFactor = 0.05;
                this.enablePan = false;
                this.minDistance = 1;
                this.maxDistance = 5;

                let spherical = {
                    radius: 3,
                    phi: Math.PI / 4,
                    theta: Math.PI / 4,
                };
                let sphericalDelta = { phi: 0, theta: 0 };
                let scale = 1;
                let isDragging = false;
                let previousMouse = { x: 0, y: 0 };

                const updateCamera = () => {
                    const r = spherical.radius;
                    camera.position.x =
                        r * Math.sin(spherical.phi) * Math.cos(spherical.theta);
                    camera.position.y = r * Math.cos(spherical.phi);
                    camera.position.z =
                        r * Math.sin(spherical.phi) * Math.sin(spherical.theta);
                    camera.lookAt(0, 0, 0);
                };

                const onMouseDown = (e) => {
                    if (!this.enabled) return;
                    isDragging = true;
                    previousMouse.x = e.clientX;
                    previousMouse.y = e.clientY;
                };

                const onMouseMove = (e) => {
                    if (!isDragging || !this.enabled) return;
                    const deltaX = e.clientX - previousMouse.x;
                    const deltaY = e.clientY - previousMouse.y;
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi = Math.max(
                        0.1,
                        Math.min(Math.PI - 0.1, spherical.phi + deltaY * 0.01),
                    );
                    previousMouse.x = e.clientX;
                    previousMouse.y = e.clientY;
                };

                const onMouseUp = () => {
                    isDragging = false;
                };

                const onWheel = (e) => {
                    if (!this.enabled) return;
                    e.preventDefault();
                    spherical.radius = Math.max(
                        this.minDistance,
                        Math.min(
                            this.maxDistance,
                            spherical.radius + e.deltaY * 0.002,
                        ),
                    );
                };

                domElement.addEventListener("mousedown", onMouseDown);
                domElement.addEventListener("mousemove", onMouseMove);
                domElement.addEventListener("mouseup", onMouseUp);
                domElement.addEventListener("mouseleave", onMouseUp);
                domElement.addEventListener("wheel", onWheel, {
                    passive: false,
                });

                // Touch support
                domElement.addEventListener("touchstart", (e) => {
                    if (e.touches.length === 1) {
                        isDragging = true;
                        previousMouse.x = e.touches[0].clientX;
                        previousMouse.y = e.touches[0].clientY;
                    }
                });
                domElement.addEventListener("touchmove", (e) => {
                    if (!isDragging || e.touches.length !== 1) return;
                    const deltaX = e.touches[0].clientX - previousMouse.x;
                    const deltaY = e.touches[0].clientY - previousMouse.y;
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi = Math.max(
                        0.1,
                        Math.min(Math.PI - 0.1, spherical.phi + deltaY * 0.01),
                    );
                    previousMouse.x = e.touches[0].clientX;
                    previousMouse.y = e.touches[0].clientY;
                });
                domElement.addEventListener("touchend", () => {
                    isDragging = false;
                });

                this.update = () => {
                    updateCamera();
                };
                this.reset = () => {
                    spherical = {
                        radius: 3,
                        phi: Math.PI / 4,
                        theta: Math.PI / 4,
                    };
                    updateCamera();
                };

                updateCamera();
            };
        </script>

        <script>
            // ============================================================
            // CONFIGURATION
            // ============================================================
            const CONFIG = {
                wavetable: {
                    samplesPerWaveform: 256,
                    numberOfFrames: 32,
                    gridSizeKm: 10.0, // 10km² for more terrain variation
                },
                audio: {
                    polyphony: 8,
                },
                api: {
                    // CORS proxy - leave empty when deployed, use "https://corsproxy.io/?" for local file://
                    corsProxy: "",
                    primary: "https://api.open-elevation.com/api/v1/lookup",
                    fallback: "https://api.opentopodata.org/v1/srtm30m",
                    maxLocationsPerRequest: 1000, // ~9 requests for 8192 points
                    delayBetweenChunks: 100,
                },
                map: {
                    defaultCenter: [46.8182, 8.2275], // Swiss Alps
                    defaultZoom: 6,
                },
            };

            // ============================================================
            // TERRAIN DATA SERVICE
            // ============================================================
            class TerrainService {
                constructor() {
                    this.cache = new Map();
                }

                /**
                 * Generate cache key from coordinates.
                 */
                getCacheKey(lat, lng) {
                    return `${lat.toFixed(4)},${lng.toFixed(4)}`;
                }

                /**
                 * Generate grid of coordinates for elevation sampling.
                 */
                generateGridLocations(centerLat, centerLng, config) {
                    const locations = [];
                    const { samplesPerWaveform, numberOfFrames, gridSizeKm } =
                        config;

                    const latOffset = gridSizeKm / 2 / 111.0;
                    const lngOffset =
                        gridSizeKm /
                        2 /
                        (111.0 * Math.cos((centerLat * Math.PI) / 180));

                    const latStep = (2 * latOffset) / (numberOfFrames - 1);
                    const lngStep = (2 * lngOffset) / (samplesPerWaveform - 1);

                    for (let frame = 0; frame < numberOfFrames; frame++) {
                        const lat = centerLat + latOffset - frame * latStep;

                        for (
                            let sample = 0;
                            sample < samplesPerWaveform;
                            sample++
                        ) {
                            const lng =
                                centerLng - lngOffset + sample * lngStep;
                            locations.push({ latitude: lat, longitude: lng });
                        }
                    }

                    return locations;
                }

                /**
                 * Fetch elevation data with caching.
                 */
                async fetchElevation(centerLat, centerLng) {
                    const cacheKey = this.getCacheKey(centerLat, centerLng);

                    if (this.cache.has(cacheKey)) {
                        console.log("Using cached terrain data");
                        return this.cache.get(cacheKey);
                    }

                    const locations = this.generateGridLocations(
                        centerLat,
                        centerLng,
                        CONFIG.wavetable,
                    );

                    console.log(
                        `Fetching ${locations.length} elevation points...`,
                    );

                    let result;
                    try {
                        result = await this.fetchWithChunking(
                            locations,
                            CONFIG.api.primary,
                            "primary",
                        );
                    } catch (primaryError) {
                        console.warn(
                            "Primary API failed:",
                            primaryError.message,
                        );
                        app.setStatus(
                            "Primary API failed, trying backup...",
                            "warning",
                        );

                        try {
                            result =
                                await this.fetchFromOpenTopoData(locations);
                        } catch (fallbackError) {
                            console.warn(
                                "Fallback API failed:",
                                fallbackError.message,
                            );
                            app.setStatus(
                                "APIs unavailable, using demo terrain",
                                "warning",
                            );
                            result = this.generateDemoTerrain(
                                centerLat,
                                centerLng,
                            );
                        }
                    }

                    this.cache.set(cacheKey, result);
                    return result;
                }

                /**
                 * Fetch with chunking to avoid API timeouts.
                 */
                async fetchWithChunking(locations, apiUrl, apiName) {
                    const { maxLocationsPerRequest, delayBetweenChunks } =
                        CONFIG.api;
                    const chunks = [];

                    for (
                        let i = 0;
                        i < locations.length;
                        i += maxLocationsPerRequest
                    ) {
                        chunks.push(
                            locations.slice(i, i + maxLocationsPerRequest),
                        );
                    }

                    const results = [];
                    for (let i = 0; i < chunks.length; i++) {
                        app.setStatus(
                            `Fetching terrain (${apiName})... ${i + 1}/${chunks.length}`,
                            "loading",
                        );

                        const fetchUrl = CONFIG.api.corsProxy
                            ? CONFIG.api.corsProxy + encodeURIComponent(apiUrl)
                            : apiUrl;
                        const response = await fetch(fetchUrl, {
                            method: "POST",
                            headers: {
                                Accept: "application/json",
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({ locations: chunks[i] }),
                        });

                        if (!response.ok) {
                            throw new Error(`API returned ${response.status}`);
                        }

                        const data = await response.json();

                        if (!data.results || data.results.length === 0) {
                            throw new Error("No results in API response");
                        }

                        results.push(
                            ...data.results.map((r) => r.elevation ?? 0),
                        );

                        if (i < chunks.length - 1) {
                            await this.sleep(delayBetweenChunks);
                        }
                    }

                    console.log(`Received ${results.length} elevation points`);
                    return this.normalizeToWavetable(results);
                }

                /**
                 * Fetch from Open Topo Data.
                 */
                async fetchFromOpenTopoData(locations) {
                    const { maxLocationsPerRequest, delayBetweenChunks } =
                        CONFIG.api;
                    const chunks = [];

                    for (
                        let i = 0;
                        i < locations.length;
                        i += maxLocationsPerRequest
                    ) {
                        chunks.push(
                            locations.slice(i, i + maxLocationsPerRequest),
                        );
                    }

                    const results = [];
                    for (let i = 0; i < chunks.length; i++) {
                        app.setStatus(
                            `Fetching terrain (backup)... ${i + 1}/${chunks.length}`,
                            "loading",
                        );

                        const locString = chunks[i]
                            .map((l) => `${l.latitude},${l.longitude}`)
                            .join("|");

                        const fallbackUrl = `${CONFIG.api.fallback}?locations=${locString}`;
                        const fetchUrl = CONFIG.api.corsProxy
                            ? CONFIG.api.corsProxy +
                              encodeURIComponent(fallbackUrl)
                            : fallbackUrl;
                        const response = await fetch(fetchUrl);

                        if (!response.ok) {
                            throw new Error(
                                `Fallback API returned ${response.status}`,
                            );
                        }

                        const data = await response.json();

                        if (!data.results || data.results.length === 0) {
                            throw new Error(
                                "No results in fallback API response",
                            );
                        }

                        results.push(
                            ...data.results.map((r) => r.elevation ?? 0),
                        );

                        if (i < chunks.length - 1) {
                            await this.sleep(delayBetweenChunks);
                        }
                    }

                    console.log(
                        `Received ${results.length} elevation points from fallback`,
                    );
                    return this.normalizeToWavetable(results);
                }

                /**
                 * Generate procedural terrain for demo/fallback.
                 */
                generateDemoTerrain(centerLat = 0, centerLng = 0) {
                    console.warn(
                        "TerrainService: USING DEMO TERRAIN (APIs failed)",
                    );
                    const { samplesPerWaveform, numberOfFrames } =
                        CONFIG.wavetable;
                    const elevations = [];

                    // Use coordinates as seed for variation
                    const seed = (centerLat * 1000 + centerLng) % 1000;

                    for (let f = 0; f < numberOfFrames; f++) {
                        for (let s = 0; s < samplesPerWaveform; s++) {
                            const value =
                                Math.sin(s * 0.05 + seed * 0.01) * 500 +
                                Math.sin(s * 0.1 + f * 0.2 + seed * 0.02) *
                                    300 +
                                Math.sin(s * 0.02 - f * 0.1 + seed * 0.03) *
                                    200 +
                                Math.sin(s * 0.25 + f * 0.5) * 100;
                            elevations.push(value);
                        }
                    }

                    console.log("Generated demo terrain");
                    return this.normalizeToWavetable(elevations);
                }

                /**
                 * Normalize elevation data to wavetable format.
                 */
                normalizeToWavetable(elevations) {
                    const { samplesPerWaveform, numberOfFrames } =
                        CONFIG.wavetable;

                    let globalMin = Infinity;
                    let globalMax = -Infinity;

                    for (const elev of elevations) {
                        if (
                            elev !== null &&
                            elev !== undefined &&
                            !isNaN(elev)
                        ) {
                            globalMin = Math.min(globalMin, elev);
                            globalMax = Math.max(globalMax, elev);
                        }
                    }

                    // Handle edge case of flat terrain
                    if (globalMin === globalMax) {
                        globalMax = globalMin + 1;
                    }

                    const range = globalMax - globalMin;
                    const midpoint = (globalMax + globalMin) / 2;

                    const frames = [];
                    for (let f = 0; f < numberOfFrames; f++) {
                        const frame = new Float32Array(samplesPerWaveform);
                        const frameStart = f * samplesPerWaveform;

                        for (let s = 0; s < samplesPerWaveform; s++) {
                            const rawValue = elevations[frameStart + s] ?? 0;
                            frame[s] =
                                range > 0
                                    ? (rawValue - midpoint) / (range / 2)
                                    : 0;
                        }

                        frames.push(frame);
                    }

                    console.log(
                        `Normalized wavetable: ${frames.length} frames, elevation ${Math.round(globalMin)}m - ${Math.round(globalMax)}m`,
                    );

                    return {
                        frames,
                        metadata: { globalMin, globalMax, range },
                    };
                }

                sleep(ms) {
                    return new Promise((resolve) => setTimeout(resolve, ms));
                }
            }

            // ============================================================
            // SHIMMER REVERB (Freeverb/Greyhole inspired)
            // ============================================================
            class ShimmerReverb {
                constructor(audioCtx) {
                    this.audioCtx = audioCtx;
                    this.input = audioCtx.createGain();
                    this.output = audioCtx.createGain();

                    // Parameters
                    this.decay = 0.85;
                    this.damping = 0.3;
                    this.size = 1.0;
                    this.modDepth = 0.002;
                    this.modRate = 0.5;

                    // Freeverb-style comb filter delay times (in seconds at 44.1kHz, scaled)
                    this.combTunings = [
                        0.0297, 0.0371, 0.0411, 0.0437, 0.0229, 0.0267, 0.0313,
                        0.0359,
                    ];

                    // Allpass filter delay times
                    this.allpassTunings = [0.0053, 0.0127, 0.0091, 0.0107];

                    this.combs = [];
                    this.allpasses = [];
                    this.dampFilters = [];
                    this.modOscs = [];
                    this.modGains = [];

                    this.buildGraph();
                }

                buildGraph() {
                    const ctx = this.audioCtx;

                    // Pre-delay
                    this.preDelay = ctx.createDelay(0.5);
                    this.preDelay.delayTime.value = 0.02;

                    // Input diffusion (allpass chain)
                    this.inputDiffusion = [];
                    for (let i = 0; i < 2; i++) {
                        const ap = this.createAllpass(0.005 + i * 0.003, 0.5);
                        this.inputDiffusion.push(ap);
                    }

                    // Parallel comb filters (8 total, 4 per channel for stereo)
                    const combMergerL = ctx.createGain();
                    const combMergerR = ctx.createGain();
                    combMergerL.gain.value = 0.25;
                    combMergerR.gain.value = 0.25;

                    for (let i = 0; i < 8; i++) {
                        const comb = this.createModulatedComb(
                            this.combTunings[i] * this.size,
                            this.decay,
                            i,
                        );
                        this.combs.push(comb);

                        // Route to L or R
                        if (i < 4) {
                            comb.output.connect(combMergerL);
                        } else {
                            comb.output.connect(combMergerR);
                        }
                    }

                    // Output allpass diffusion (stereo)
                    const allpassChainL = this.createAllpassChain();
                    const allpassChainR = this.createAllpassChain();

                    // Stereo output
                    this.stereoMerger = ctx.createChannelMerger(2);

                    // Connect the graph
                    this.input.connect(this.preDelay);

                    // Input diffusion chain
                    let lastNode = this.preDelay;
                    for (const ap of this.inputDiffusion) {
                        lastNode.connect(ap.input);
                        lastNode = ap.output;
                    }

                    // Fan out to combs
                    for (const comb of this.combs) {
                        lastNode.connect(comb.input);
                    }

                    // Through allpass chains to stereo output
                    combMergerL.connect(allpassChainL.input);
                    combMergerR.connect(allpassChainR.input);

                    allpassChainL.output.connect(this.stereoMerger, 0, 0);
                    allpassChainR.output.connect(this.stereoMerger, 0, 1);

                    // Cross-feed for wider stereo
                    const crossL = ctx.createGain();
                    const crossR = ctx.createGain();
                    crossL.gain.value = 0.2;
                    crossR.gain.value = 0.2;
                    allpassChainL.output.connect(crossR);
                    allpassChainR.output.connect(crossL);
                    crossL.connect(this.stereoMerger, 0, 0);
                    crossR.connect(this.stereoMerger, 0, 1);

                    this.stereoMerger.connect(this.output);
                }

                createModulatedComb(delayTime, feedback, index) {
                    const ctx = this.audioCtx;

                    const input = ctx.createGain();
                    const delay = ctx.createDelay(1.0);
                    const feedbackGain = ctx.createGain();
                    const damper = ctx.createBiquadFilter();
                    const output = ctx.createGain();

                    delay.delayTime.value = delayTime;
                    feedbackGain.gain.value = feedback;

                    // Damping filter (lowpass in feedback loop)
                    damper.type = "lowpass";
                    damper.frequency.value = 4000 * (1 - this.damping);
                    damper.Q.value = 0.5;
                    this.dampFilters.push(damper);

                    // LFO for delay time modulation (Greyhole-style shimmer)
                    const lfo = ctx.createOscillator();
                    const lfoGain = ctx.createGain();
                    lfo.type = "sine";
                    lfo.frequency.value = this.modRate * (0.8 + index * 0.1);
                    lfoGain.gain.value = this.modDepth * delayTime;
                    lfo.connect(lfoGain);
                    lfoGain.connect(delay.delayTime);
                    lfo.start();
                    this.modOscs.push(lfo);
                    this.modGains.push({ gain: lfoGain, baseDelay: delayTime });

                    // Comb filter topology
                    input.connect(delay);
                    delay.connect(output);
                    delay.connect(damper);
                    damper.connect(feedbackGain);
                    feedbackGain.connect(delay);

                    return { input, output, delay, feedbackGain, damper };
                }

                createAllpass(delayTime, feedback) {
                    const ctx = this.audioCtx;

                    const input = ctx.createGain();
                    const output = ctx.createGain();
                    const delay = ctx.createDelay(0.5);
                    const feedbackGain = ctx.createGain();
                    const feedforwardGain = ctx.createGain();

                    delay.delayTime.value = delayTime;
                    feedbackGain.gain.value = feedback;
                    feedforwardGain.gain.value = -feedback;

                    // Allpass topology
                    input.connect(delay);
                    input.connect(feedforwardGain);
                    delay.connect(output);
                    delay.connect(feedbackGain);
                    feedbackGain.connect(input);
                    feedforwardGain.connect(output);

                    return { input, output, delay };
                }

                createAllpassChain() {
                    const ctx = this.audioCtx;
                    const input = ctx.createGain();
                    const output = ctx.createGain();

                    let lastNode = input;
                    for (const time of this.allpassTunings) {
                        const ap = this.createAllpass(time * this.size, 0.5);
                        this.allpasses.push(ap);
                        lastNode.connect(ap.input);
                        lastNode = ap.output;
                    }
                    lastNode.connect(output);

                    return { input, output };
                }

                setDecay(value) {
                    // value 0-1, map to feedback 0.7-0.98
                    this.decay = 0.7 + value * 0.28;
                    for (const comb of this.combs) {
                        comb.feedbackGain.gain.setValueAtTime(
                            this.decay,
                            this.audioCtx.currentTime,
                        );
                    }
                }

                setDamping(value) {
                    // value 0-1
                    this.damping = value;
                    const freq = 8000 * (1 - value * 0.8);
                    for (const filter of this.dampFilters) {
                        filter.frequency.setValueAtTime(
                            freq,
                            this.audioCtx.currentTime,
                        );
                    }
                }

                setSize(value) {
                    // value 0-1, affects delay times
                    this.size = 0.5 + value * 1.5;
                    this.combs.forEach((comb, i) => {
                        const newTime = this.combTunings[i] * this.size;
                        comb.delay.delayTime.setValueAtTime(
                            newTime,
                            this.audioCtx.currentTime,
                        );
                    });
                }

                setModulation(depth, rate) {
                    this.modDepth = depth;
                    this.modRate = rate;
                    this.modOscs.forEach((osc, i) => {
                        osc.frequency.setValueAtTime(
                            rate * (0.8 + i * 0.1),
                            this.audioCtx.currentTime,
                        );
                    });
                    this.modGains.forEach((mg) => {
                        mg.gain.gain.setValueAtTime(
                            depth * mg.baseDelay,
                            this.audioCtx.currentTime,
                        );
                    });
                }
            }

            // ============================================================
            // AUDIO ENGINE
            // ============================================================
            class AudioEngine {
                constructor() {
                    this.audioCtx = null;
                    this.masterGain = null;
                    this.filter = null;
                    this.dryGain = null;
                    this.wetGain = null;
                    this.reverb = null;
                    this.periodicWaves = [];
                    this.voices = new Map();
                    this.morphPosition = 0.5;
                    this.adsr = {
                        attack: 0.01,
                        decay: 0.1,
                        sustain: 0.7,
                        release: 0.3,
                    };
                    this.filterCutoff = 20000;
                    this.filterResonance = 0;
                    this.reverbMix = 0;
                    this.reverbDecay = 0.5;
                    this.initialized = false;
                }

                async initialize() {
                    if (this.initialized) return;

                    this.audioCtx = new (
                        window.AudioContext || window.webkitAudioContext
                    )();

                    // Create filter (low-pass)
                    this.filter = this.audioCtx.createBiquadFilter();
                    this.filter.type = "lowpass";
                    this.filter.frequency.value = this.filterCutoff;
                    this.filter.Q.value = this.filterResonance;

                    // Create shimmer reverb
                    this.reverb = new ShimmerReverb(this.audioCtx);

                    // Dry/wet mix for reverb
                    this.dryGain = this.audioCtx.createGain();
                    this.wetGain = this.audioCtx.createGain();
                    this.dryGain.gain.value = 1;
                    this.wetGain.gain.value = 0;

                    // Master gain
                    this.masterGain = this.audioCtx.createGain();
                    this.masterGain.gain.value = 0.7;

                    // Signal routing:
                    // voices -> filter -> dryGain -> masterGain -> destination
                    //                  -> reverb -> wetGain -> masterGain
                    this.filter.connect(this.dryGain);
                    this.filter.connect(this.reverb.input);
                    this.reverb.output.connect(this.wetGain);
                    this.dryGain.connect(this.masterGain);
                    this.wetGain.connect(this.masterGain);
                    this.masterGain.connect(this.audioCtx.destination);

                    this.loadDefaultWave();

                    this.initialized = true;
                    console.log("Audio engine initialized");
                }

                setFilterCutoff(frequency) {
                    this.filterCutoff = frequency;
                    if (this.filter) {
                        this.filter.frequency.setValueAtTime(
                            frequency,
                            this.audioCtx.currentTime,
                        );
                    }
                }

                setFilterResonance(q) {
                    this.filterResonance = q;
                    if (this.filter) {
                        this.filter.Q.setValueAtTime(
                            q,
                            this.audioCtx.currentTime,
                        );
                    }
                }

                setReverbMix(mix) {
                    this.reverbMix = mix;
                    if (this.dryGain && this.wetGain) {
                        this.dryGain.gain.setValueAtTime(
                            1 - mix * 0.5,
                            this.audioCtx.currentTime,
                        );
                        this.wetGain.gain.setValueAtTime(
                            mix,
                            this.audioCtx.currentTime,
                        );
                    }
                }

                setReverbDecay(decay) {
                    // decay slider 0.1-5 maps to 0-1 for reverb
                    this.reverbDecay = decay;
                    if (this.reverb) {
                        const normalized = Math.min(1, (decay - 0.1) / 4.9);
                        this.reverb.setDecay(normalized);
                    }
                }

                loadDefaultWave() {
                    const real = new Float32Array(2);
                    const imag = new Float32Array(2);
                    real[0] = 0;
                    imag[0] = 0;
                    real[1] = 0;
                    imag[1] = 1;

                    const wave = this.audioCtx.createPeriodicWave(real, imag);
                    this.periodicWaves = [wave];
                }

                loadWavetable(frames) {
                    if (!this.initialized) {
                        console.warn("Audio not initialized");
                        return;
                    }

                    this.periodicWaves = frames.map((frame) =>
                        this.frameToPeriodicWave(frame),
                    );
                    console.log(
                        `Audio: Loaded ${this.periodicWaves.length} wavetable frames`,
                    );
                }

                frameToPeriodicWave(frame) {
                    const n = frame.length;
                    const real = new Float32Array(n / 2);
                    const imag = new Float32Array(n / 2);

                    for (let k = 0; k < n / 2; k++) {
                        let sumReal = 0;
                        let sumImag = 0;

                        for (let t = 0; t < n; t++) {
                            const angle = (2 * Math.PI * k * t) / n;
                            sumReal += frame[t] * Math.cos(angle);
                            sumImag -= frame[t] * Math.sin(angle);
                        }

                        real[k] = sumReal / n;
                        imag[k] = sumImag / n;
                    }

                    real[0] = 0;
                    imag[0] = 0;

                    return this.audioCtx.createPeriodicWave(real, imag, {
                        disableNormalization: false,
                    });
                }

                noteOn(noteId, frequency, velocity = 1.0) {
                    if (!this.initialized || this.periodicWaves.length === 0)
                        return;

                    this.noteOff(noteId);

                    const voice = this.createVoice(frequency, velocity);
                    this.voices.set(noteId, voice);

                    this.triggerAttack(voice.envGain);

                    voice.oscA.start();
                    voice.oscB.start();
                }

                createVoice(frequency, velocity) {
                    const oscA = this.audioCtx.createOscillator();
                    const oscB = this.audioCtx.createOscillator();
                    const gainA = this.audioCtx.createGain();
                    const gainB = this.audioCtx.createGain();
                    const envGain = this.audioCtx.createGain();
                    const velGain = this.audioCtx.createGain();

                    oscA.connect(gainA);
                    oscB.connect(gainB);
                    gainA.connect(envGain);
                    gainB.connect(envGain);
                    envGain.connect(velGain);
                    // Connect to filter (which then goes to reverb/master)
                    velGain.connect(this.filter);

                    oscA.frequency.value = frequency;
                    oscB.frequency.value = frequency;

                    velGain.gain.value = velocity;

                    this.applyMorph({ oscA, oscB, gainA, gainB });

                    envGain.gain.value = 0;

                    return { oscA, oscB, gainA, gainB, envGain, velGain };
                }

                applyMorph(voice) {
                    if (this.periodicWaves.length <= 1) {
                        voice.oscA.setPeriodicWave(this.periodicWaves[0]);
                        voice.oscB.setPeriodicWave(this.periodicWaves[0]);
                        voice.gainA.gain.value = 1;
                        voice.gainB.gain.value = 0;
                        return;
                    }

                    const frameIndex =
                        this.morphPosition * (this.periodicWaves.length - 1);
                    const lowerFrame = Math.floor(frameIndex);
                    const upperFrame = Math.min(
                        lowerFrame + 1,
                        this.periodicWaves.length - 1,
                    );
                    const blend = frameIndex - lowerFrame;

                    voice.oscA.setPeriodicWave(this.periodicWaves[lowerFrame]);
                    voice.oscB.setPeriodicWave(this.periodicWaves[upperFrame]);
                    voice.gainA.gain.value = 1 - blend;
                    voice.gainB.gain.value = blend;
                }

                noteOff(noteId) {
                    const voice = this.voices.get(noteId);
                    if (!voice) return;

                    this.triggerRelease(voice.envGain);

                    const stopTime =
                        this.audioCtx.currentTime + this.adsr.release + 0.1;
                    voice.oscA.stop(stopTime);
                    voice.oscB.stop(stopTime);

                    this.voices.delete(noteId);
                }

                triggerAttack(gainNode) {
                    const now = this.audioCtx.currentTime;
                    gainNode.gain.cancelScheduledValues(now);
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(
                        1,
                        now + this.adsr.attack,
                    );
                    gainNode.gain.linearRampToValueAtTime(
                        this.adsr.sustain,
                        now + this.adsr.attack + this.adsr.decay,
                    );
                }

                triggerRelease(gainNode) {
                    const now = this.audioCtx.currentTime;
                    gainNode.gain.cancelScheduledValues(now);
                    gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                    gainNode.gain.linearRampToValueAtTime(
                        0,
                        now + this.adsr.release,
                    );
                }

                setMorphPosition(position) {
                    this.morphPosition = Math.max(0, Math.min(1, position));

                    for (const voice of this.voices.values()) {
                        this.applyMorph(voice);
                    }
                }

                setMasterVolume(volume) {
                    if (this.masterGain) {
                        this.masterGain.gain.value = volume;
                    }
                }

                setADSR(attack, decay, sustain, release) {
                    this.adsr = { attack, decay, sustain, release };
                }
            }

            // ============================================================
            // MIDI CONTROLLER
            // ============================================================
            class MidiController {
                constructor(onNoteOn, onNoteOff, onCC) {
                    this.onNoteOn = onNoteOn;
                    this.onNoteOff = onNoteOff;
                    this.onCC = onCC;
                    this.midiAccess = null;
                    this.inputs = [];
                }

                async initialize() {
                    if (!navigator.requestMIDIAccess) {
                        console.log("Web MIDI not supported");
                        return false;
                    }

                    try {
                        this.midiAccess = await navigator.requestMIDIAccess();
                        this.setupInputs();
                        this.midiAccess.onstatechange = () =>
                            this.setupInputs();
                        return true;
                    } catch (err) {
                        console.warn("MIDI access denied:", err);
                        return false;
                    }
                }

                setupInputs() {
                    this.inputs = [];

                    for (const input of this.midiAccess.inputs.values()) {
                        input.onmidimessage = (e) => this.handleMessage(e);
                        this.inputs.push(input);
                    }

                    if (this.inputs.length > 0) {
                        const names = this.inputs.map((i) => i.name).join(", ");
                        app.setMidiStatus(true, names);
                    } else {
                        app.setMidiStatus(false, "No MIDI devices");
                    }
                }

                handleMessage(event) {
                    const [status, data1, data2] = event.data;
                    const command = status >> 4;

                    switch (command) {
                        case 0x9:
                            if (data2 > 0) {
                                const frequency =
                                    this.midiNoteToFrequency(data1);
                                const velocity = data2 / 127;
                                this.onNoteOn(data1, frequency, velocity);
                            } else {
                                this.onNoteOff(data1);
                            }
                            break;

                        case 0x8:
                            this.onNoteOff(data1);
                            break;

                        case 0xb:
                            this.onCC(data1, data2 / 127);
                            break;
                    }
                }

                midiNoteToFrequency(note) {
                    return 440 * Math.pow(2, (note - 69) / 12);
                }
            }

            // ============================================================
            // 3D TERRAIN VISUALIZATION (Three.js)
            // ============================================================
            class Terrain3DDisplay {
                constructor(canvas) {
                    this.canvas = canvas;
                    this.frames = [];
                    this.morphPosition = 0.5;
                    this.isLightMode = false;

                    this.scene = null;
                    this.camera = null;
                    this.renderer = null;
                    this.controls = null;
                    this.terrainMesh = null;
                    this.morphLine = null;

                    this.init();
                }

                init() {
                    // Scene
                    this.scene = new THREE.Scene();

                    // Camera
                    this.camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
                    this.camera.position.set(2, 1.5, 2);

                    // Renderer
                    this.renderer = new THREE.WebGLRenderer({
                        canvas: this.canvas,
                        antialias: true,
                        alpha: true,
                    });
                    this.renderer.setPixelRatio(window.devicePixelRatio);
                    this.updateColors();

                    // Controls
                    this.controls = new THREE.OrbitControls(
                        this.camera,
                        this.canvas,
                    );
                    this.controls.enableDamping = true;
                    this.controls.dampingFactor = 0.05;
                    this.controls.enablePan = false;
                    this.controls.minDistance = 1;
                    this.controls.maxDistance = 5;

                    // Initial resize
                    this.resize();

                    // Animation loop
                    this.animate();

                    // Resize observer
                    this.resizeObserver = new ResizeObserver(() =>
                        this.resize(),
                    );
                    this.resizeObserver.observe(this.canvas.parentElement);
                }

                resize() {
                    const rect =
                        this.canvas.parentElement.getBoundingClientRect();
                    const width = rect.width;
                    const height = rect.height;

                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(width, height);
                }

                updateColors() {
                    const bgColor = this.isLightMode ? 0xf5f5f5 : 0x0a0a0a;
                    this.renderer.setClearColor(bgColor, 1);

                    // Update terrain material if it exists
                    if (this.terrainMesh) {
                        this.terrainMesh.material.color.setHex(
                            this.isLightMode ? 0x000000 : 0xffffff,
                        );
                    }

                    // Update morph line if it exists (arctic blue for visibility)
                    if (this.morphLine) {
                        this.morphLine.material.color.setHex(
                            this.isLightMode ? 0x0088cc : 0x66ccff,
                        );
                    }
                }

                setLightMode(isLight) {
                    this.isLightMode = isLight;
                    this.updateColors();
                }

                setFrames(frames) {
                    console.log(
                        `Terrain3D.setFrames: received ${frames.length} frames`,
                    );
                    this.frames = frames;
                    this.buildTerrain();
                }

                setMorphPosition(position) {
                    this.morphPosition = position;
                    this.updateMorphLine();
                }

                buildTerrain() {
                    console.log("Terrain3D.buildTerrain: starting rebuild...");

                    // Remove old mesh
                    if (this.terrainMesh) {
                        this.scene.remove(this.terrainMesh);
                        this.terrainMesh.geometry.dispose();
                        this.terrainMesh.material.dispose();
                        console.log("Terrain3D.buildTerrain: removed old mesh");
                    }
                    if (this.morphLine) {
                        this.scene.remove(this.morphLine);
                        this.morphLine.geometry.dispose();
                        this.morphLine.material.dispose();
                    }

                    if (this.frames.length === 0) {
                        console.log(
                            "Terrain3D.buildTerrain: no frames, skipping",
                        );
                        return;
                    }

                    const numFrames = this.frames.length;
                    const samplesPerFrame = this.frames[0].length;

                    // Log some sample values to verify data is different
                    console.log(
                        `Terrain3D.buildTerrain: ${numFrames} frames x ${samplesPerFrame} samples`,
                    );
                    console.log(
                        "Terrain3D.buildTerrain: sample values from frame 0:",
                        this.frames[0][0].toFixed(3),
                        this.frames[0][Math.floor(samplesPerFrame / 2)].toFixed(
                            3,
                        ),
                        this.frames[0][samplesPerFrame - 1].toFixed(3),
                    );

                    // Create geometry
                    const geometry = new THREE.BufferGeometry();
                    const vertices = [];
                    const indices = [];

                    // Downsample for performance
                    const frameStep = Math.max(1, Math.floor(numFrames / 32));
                    const sampleStep = Math.max(
                        1,
                        Math.floor(samplesPerFrame / 64),
                    );

                    const actualFrames = [];
                    const actualSamples = [];

                    for (let f = 0; f < numFrames; f += frameStep) {
                        actualFrames.push(f);
                    }
                    for (let s = 0; s < samplesPerFrame; s += sampleStep) {
                        actualSamples.push(s);
                    }

                    // Generate vertices
                    for (let fi = 0; fi < actualFrames.length; fi++) {
                        const f = actualFrames[fi];
                        const z = fi / (actualFrames.length - 1) - 0.5; // -0.5 to 0.5

                        for (let si = 0; si < actualSamples.length; si++) {
                            const s = actualSamples[si];
                            const x = si / (actualSamples.length - 1) - 0.5; // -0.5 to 0.5
                            const y = this.frames[f][s] * 0.3; // Height scale

                            vertices.push(x, y, z);
                        }
                    }

                    // Generate indices for wireframe
                    const cols = actualSamples.length;
                    const rows = actualFrames.length;

                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols - 1; c++) {
                            const i = r * cols + c;
                            indices.push(i, i + 1);
                        }
                    }

                    for (let c = 0; c < cols; c++) {
                        for (let r = 0; r < rows - 1; r++) {
                            const i = r * cols + c;
                            indices.push(i, i + cols);
                        }
                    }

                    geometry.setAttribute(
                        "position",
                        new THREE.Float32BufferAttribute(vertices, 3),
                    );
                    geometry.setIndex(indices);

                    // Create wireframe material (subtle, so morph line stands out)
                    const material = new THREE.LineBasicMaterial({
                        color: this.isLightMode ? 0x000000 : 0xffffff,
                        linewidth: 1,
                        transparent: true,
                        opacity: 0.25,
                    });

                    this.terrainMesh = new THREE.LineSegments(
                        geometry,
                        material,
                    );
                    this.scene.add(this.terrainMesh);

                    // Create morph line
                    this.createMorphLine();

                    // Reset camera
                    this.resetView();
                }

                createMorphLine() {
                    if (this.frames.length === 0) return;

                    const samplesPerFrame = this.frames[0].length;
                    const sampleStep = Math.max(
                        1,
                        Math.floor(samplesPerFrame / 64),
                    );

                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(
                        Math.ceil(samplesPerFrame / sampleStep) * 3,
                    );

                    geometry.setAttribute(
                        "position",
                        new THREE.BufferAttribute(positions, 3),
                    );

                    const material = new THREE.LineBasicMaterial({
                        color: this.isLightMode ? 0x0088cc : 0x66ccff,
                        linewidth: 3,
                        transparent: true,
                        opacity: 1,
                    });

                    this.morphLine = new THREE.Line(geometry, material);
                    this.scene.add(this.morphLine);

                    this.updateMorphLine();
                }

                updateMorphLine() {
                    if (!this.morphLine || this.frames.length === 0) return;

                    const numFrames = this.frames.length;
                    const samplesPerFrame = this.frames[0].length;
                    const sampleStep = Math.max(
                        1,
                        Math.floor(samplesPerFrame / 64),
                    );

                    // Interpolate frame
                    const frameIndex = this.morphPosition * (numFrames - 1);
                    const lowerIndex = Math.floor(frameIndex);
                    const upperIndex = Math.min(lowerIndex + 1, numFrames - 1);
                    const blend = frameIndex - lowerIndex;

                    const z = this.morphPosition - 0.5;

                    const positions =
                        this.morphLine.geometry.attributes.position.array;
                    let idx = 0;

                    for (let s = 0; s < samplesPerFrame; s += sampleStep) {
                        const x = s / (samplesPerFrame - 1) - 0.5;
                        const yLower = this.frames[lowerIndex][s];
                        const yUpper = this.frames[upperIndex][s];
                        const y = (yLower * (1 - blend) + yUpper * blend) * 0.3;

                        positions[idx++] = x;
                        positions[idx++] = y;
                        positions[idx++] = z;
                    }

                    this.morphLine.geometry.attributes.position.needsUpdate = true;
                }

                resetView() {
                    this.camera.position.set(2, 1.5, 2);
                    this.camera.lookAt(0, 0, 0);
                    this.controls.reset();
                }

                animate = () => {
                    requestAnimationFrame(this.animate);
                    this.controls.update();
                    this.renderer.render(this.scene, this.camera);
                };
            }

            // ============================================================
            // WAVEFORM DISPLAY (2D Canvas)
            // ============================================================
            class WaveformDisplay {
                constructor(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext("2d");
                    this.frames = [];
                    this.morphPosition = 0.5;
                    this.isLightMode = false;
                    this.resizeObserver = new ResizeObserver(() =>
                        this.resize(),
                    );
                    this.resizeObserver.observe(canvas.parentElement);
                    this.resize();
                }

                resize() {
                    const rect =
                        this.canvas.parentElement.getBoundingClientRect();
                    this.canvas.width = rect.width;
                    this.canvas.height = rect.height;
                    this.draw();
                }

                setLightMode(isLight) {
                    this.isLightMode = isLight;
                    this.draw();
                }

                setFrames(frames) {
                    this.frames = frames;
                    console.log(
                        `WaveformDisplay: received ${frames.length} frames`,
                    );
                    this.draw();
                }

                setMorphPosition(position) {
                    this.morphPosition = position;
                    this.draw();
                }

                draw() {
                    const { ctx, canvas, frames, morphPosition, isLightMode } =
                        this;
                    const { width, height } = canvas;
                    const padding = 20;

                    const bgColor = isLightMode ? "#f5f5f5" : "#000000";
                    const lineColor = isLightMode ? "#000000" : "#ffffff";
                    const mutedColor = isLightMode ? "#dddddd" : "#222222";

                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, width, height);

                    if (frames.length === 0) {
                        ctx.strokeStyle = mutedColor;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(padding, height / 2);
                        ctx.lineTo(width - padding, height / 2);
                        ctx.stroke();
                        return;
                    }

                    const frame = this.getInterpolatedFrame(morphPosition);

                    ctx.strokeStyle = lineColor;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();

                    const drawWidth = width - padding * 2;
                    const drawHeight = height - padding * 2;
                    const centerY = height / 2;
                    const stepX = drawWidth / (frame.length - 1);

                    for (let i = 0; i < frame.length; i++) {
                        const x = padding + i * stepX;
                        const y = centerY - frame[i] * (drawHeight / 2) * 0.9;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }

                    ctx.stroke();
                }

                getInterpolatedFrame(position) {
                    if (this.frames.length === 0) return new Float32Array(0);
                    if (this.frames.length === 1) return this.frames[0];

                    const frameIndex = position * (this.frames.length - 1);
                    const lowerIndex = Math.floor(frameIndex);
                    const upperIndex = Math.min(
                        lowerIndex + 1,
                        this.frames.length - 1,
                    );
                    const blend = frameIndex - lowerIndex;

                    const lower = this.frames[lowerIndex];
                    const upper = this.frames[upperIndex];
                    const result = new Float32Array(lower.length);

                    for (let i = 0; i < lower.length; i++) {
                        result[i] = lower[i] * (1 - blend) + upper[i] * blend;
                    }

                    return result;
                }
            }

            // ============================================================
            // MAP CONTROLLER
            // ============================================================
            class MapController {
                constructor(containerId, onLocationSelect) {
                    this.containerId = containerId;
                    this.onLocationSelect = onLocationSelect;
                    this.map = null;
                    this.marker = null;
                    this.areaRect = null;
                }

                initialize() {
                    this.map = L.map(this.containerId, {
                        center: CONFIG.map.defaultCenter,
                        zoom: CONFIG.map.defaultZoom,
                        zoomControl: true,
                    });

                    L.tileLayer(
                        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                        {
                            attribution: "© OpenStreetMap",
                        },
                    ).addTo(this.map);

                    this.map.on("click", (e) => {
                        const { lat, lng } = e.latlng;
                        this.showSelection(lat, lng);
                        this.onLocationSelect(lat, lng);
                    });
                }

                goTo(lat, lng, zoom = 10) {
                    this.map.setView([lat, lng], zoom);
                    this.showSelection(lat, lng);
                    this.onLocationSelect(lat, lng);
                }

                showSelection(lat, lng) {
                    if (this.marker) this.map.removeLayer(this.marker);
                    if (this.areaRect) this.map.removeLayer(this.areaRect);

                    this.marker = L.circleMarker([lat, lng], {
                        radius: 6,
                        color: "#ffffff",
                        fillColor: "#ffffff",
                        fillOpacity: 1,
                        weight: 2,
                    }).addTo(this.map);

                    const latOffset = CONFIG.wavetable.gridSizeKm / 2 / 111.0;
                    const lngOffset =
                        CONFIG.wavetable.gridSizeKm /
                        2 /
                        (111.0 * Math.cos((lat * Math.PI) / 180));

                    const bounds = [
                        [lat - latOffset, lng - lngOffset],
                        [lat + latOffset, lng + lngOffset],
                    ];

                    this.areaRect = L.rectangle(bounds, {
                        color: "#ffffff",
                        weight: 1,
                        fillOpacity: 0.1,
                    }).addTo(this.map);
                }
            }

            // ============================================================
            // SEARCH SERVICE
            // ============================================================
            class SearchService {
                /**
                 * Search for a location using Nominatim (OpenStreetMap).
                 */
                async search(query) {
                    // First check if it's coordinates (lat, lng)
                    const coordMatch = query.match(
                        /^(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)$/,
                    );
                    if (coordMatch) {
                        return {
                            lat: parseFloat(coordMatch[1]),
                            lng: parseFloat(coordMatch[2]),
                            name: `${coordMatch[1]}, ${coordMatch[2]}`,
                        };
                    }

                    // Otherwise search via Nominatim
                    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`;

                    const response = await fetch(url, {
                        headers: {
                            "User-Agent":
                                "Carta Terrain Synth (educational project)",
                        },
                    });

                    if (!response.ok) {
                        throw new Error("Search failed");
                    }

                    const results = await response.json();

                    if (results.length === 0) {
                        throw new Error("Location not found");
                    }

                    const result = results[0];
                    return {
                        lat: parseFloat(result.lat),
                        lng: parseFloat(result.lon),
                        name: result.display_name,
                    };
                }
            }

            // ============================================================
            // KEYBOARD INPUT
            // ============================================================
            class KeyboardInput {
                constructor(onNoteOn, onNoteOff) {
                    this.onNoteOn = onNoteOn;
                    this.onNoteOff = onNoteOff;
                    this.activeKeys = new Set();
                    this.keyElements = document.querySelectorAll(".key");
                    this.keyMap = new Map();

                    this.keyElements.forEach((el) => {
                        const key = el.dataset.key;
                        const freq = parseFloat(el.dataset.freq);
                        this.keyMap.set(key, { element: el, frequency: freq });
                    });
                }

                enable() {
                    document.addEventListener("keydown", this.handleKeyDown);
                    document.addEventListener("keyup", this.handleKeyUp);

                    this.keyElements.forEach((el) => {
                        el.addEventListener("mousedown", this.handleMouseDown);
                        el.addEventListener("mouseup", this.handleMouseUp);
                        el.addEventListener("mouseleave", this.handleMouseUp);
                        el.addEventListener(
                            "touchstart",
                            this.handleTouchStart,
                        );
                        el.addEventListener("touchend", this.handleTouchEnd);
                    });
                }

                handleKeyDown = (e) => {
                    if (e.target.tagName === "INPUT") return;

                    const key = e.key.toLowerCase();
                    if (this.keyMap.has(key) && !this.activeKeys.has(key)) {
                        this.activeKeys.add(key);
                        const { element, frequency } = this.keyMap.get(key);
                        element.classList.add("active");
                        this.onNoteOn(`kb_${key}`, frequency, 0.8);
                    }
                };

                handleKeyUp = (e) => {
                    const key = e.key.toLowerCase();
                    if (this.keyMap.has(key)) {
                        this.activeKeys.delete(key);
                        const { element } = this.keyMap.get(key);
                        element.classList.remove("active");
                        this.onNoteOff(`kb_${key}`);
                    }
                };

                handleMouseDown = (e) => {
                    const key = e.currentTarget.dataset.key;
                    const freq = parseFloat(e.currentTarget.dataset.freq);
                    e.currentTarget.classList.add("active");
                    this.onNoteOn(`mouse_${key}`, freq, 0.8);
                };

                handleMouseUp = (e) => {
                    const key = e.currentTarget.dataset.key;
                    e.currentTarget.classList.remove("active");
                    this.onNoteOff(`mouse_${key}`);
                };

                handleTouchStart = (e) => {
                    e.preventDefault();
                    this.handleMouseDown(e);
                };

                handleTouchEnd = (e) => {
                    e.preventDefault();
                    this.handleMouseUp(e);
                };
            }

            // ============================================================
            // SCALE MANAGER
            // ============================================================
            class ScaleManager {
                constructor() {
                    // Semitone intervals from root for each scale
                    this.scales = {
                        chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
                        major: [0, 2, 4, 5, 7, 9, 11],
                        minor: [0, 2, 3, 5, 7, 8, 10],
                        pentatonic: [0, 2, 4, 7, 9],
                        blues: [0, 3, 5, 6, 7, 10],
                        dorian: [0, 2, 3, 5, 7, 9, 10],
                        phrygian: [0, 1, 3, 5, 7, 8, 10],
                        lydian: [0, 2, 4, 6, 7, 9, 11],
                        mixolydian: [0, 2, 4, 5, 7, 9, 10],
                    };

                    // Note name to semitone offset from C
                    this.noteOffsets = {
                        C: 0,
                        "C#": 1,
                        D: 2,
                        "D#": 3,
                        E: 4,
                        F: 5,
                        "F#": 6,
                        G: 7,
                        "G#": 8,
                        A: 9,
                        "A#": 10,
                        B: 11,
                    };

                    this.rootNote = "C";
                    this.scaleType = "chromatic";
                }

                setRoot(note) {
                    this.rootNote = note;
                }

                setScale(scaleType) {
                    this.scaleType = scaleType;
                }

                /**
                 * Get all notes in scale across a given octave range
                 * Returns array of { note: 'C4', frequency: 261.63 }
                 */
                getNotesInRange(octaveLow, octaveHigh) {
                    const notes = [];
                    const rootOffset = this.noteOffsets[this.rootNote];
                    const intervals = this.scales[this.scaleType];
                    const noteNames = [
                        "C",
                        "C#",
                        "D",
                        "D#",
                        "E",
                        "F",
                        "F#",
                        "G",
                        "G#",
                        "A",
                        "A#",
                        "B",
                    ];

                    for (
                        let octave = octaveLow;
                        octave <= octaveHigh;
                        octave++
                    ) {
                        for (const interval of intervals) {
                            const semitone = rootOffset + interval;
                            const actualOctave =
                                octave + Math.floor(semitone / 12);
                            const noteIndex = semitone % 12;
                            const noteName = noteNames[noteIndex];
                            const midiNote = 12 + actualOctave * 12 + noteIndex;
                            const frequency =
                                440 * Math.pow(2, (midiNote - 69) / 12);

                            // Only include if within our octave range
                            if (
                                actualOctave >= octaveLow &&
                                actualOctave <= octaveHigh
                            ) {
                                notes.push({
                                    note: `${noteName}${actualOctave}`,
                                    frequency,
                                    midiNote,
                                });
                            }
                        }
                    }

                    // Remove duplicates and sort by frequency
                    const seen = new Set();
                    return notes
                        .filter((n) => {
                            if (seen.has(n.note)) return false;
                            seen.add(n.note);
                            return true;
                        })
                        .sort((a, b) => a.frequency - b.frequency);
                }

                /**
                 * Get notes for keyboard display (fixed keys, mapped to scale)
                 */
                getKeyboardNotes() {
                    const notes = this.getNotesInRange(4, 5);
                    // Return up to 11 notes for the keyboard keys
                    return notes.slice(0, 11);
                }
            }

            // ============================================================
            // GENERATIVE SEQUENCER
            // ============================================================
            class GenerativeSequencer {
                constructor(onNoteOn, onNoteOff) {
                    this.onNoteOn = onNoteOn;
                    this.onNoteOff = onNoteOff;
                    this.enabled = false;
                    this.bpm = 120;
                    this.probability = 0.7;
                    this.octaveLow = 4;
                    this.octaveHigh = 5;
                    this.noteLength = 1; // in beats
                    this.pattern = "random";

                    this.scaleManager = null;
                    this.currentNoteIndex = 0;
                    this.pendulumDirection = 1;
                    this.intervalId = null;
                    this.activeNote = null;
                }

                setScaleManager(scaleManager) {
                    this.scaleManager = scaleManager;
                }

                start() {
                    if (this.intervalId) return;
                    this.enabled = true;
                    this.scheduleNext();
                }

                stop() {
                    this.enabled = false;
                    if (this.intervalId) {
                        clearTimeout(this.intervalId);
                        this.intervalId = null;
                    }
                    if (this.activeNote) {
                        this.onNoteOff(this.activeNote.id);
                        this.activeNote = null;
                    }
                }

                scheduleNext() {
                    if (!this.enabled) return;

                    const beatDuration = 60000 / this.bpm;
                    const noteDuration = beatDuration * this.noteLength;

                    // Decide whether to play (probability check)
                    if (Math.random() < this.probability) {
                        this.playNote();
                    }

                    // Schedule next beat
                    this.intervalId = setTimeout(() => {
                        if (this.activeNote) {
                            this.onNoteOff(this.activeNote.id);
                            this.activeNote = null;
                        }
                        this.scheduleNext();
                    }, noteDuration);
                }

                playNote() {
                    if (!this.scaleManager) return;

                    const notes = this.scaleManager.getNotesInRange(
                        this.octaveLow,
                        this.octaveHigh,
                    );
                    if (notes.length === 0) return;

                    let note;
                    switch (this.pattern) {
                        case "random":
                            note =
                                notes[Math.floor(Math.random() * notes.length)];
                            break;
                        case "ascending":
                            note = notes[this.currentNoteIndex % notes.length];
                            this.currentNoteIndex++;
                            break;
                        case "descending":
                            note =
                                notes[
                                    notes.length -
                                        1 -
                                        (this.currentNoteIndex % notes.length)
                                ];
                            this.currentNoteIndex++;
                            break;
                        case "pendulum":
                            note = notes[this.currentNoteIndex];
                            this.currentNoteIndex += this.pendulumDirection;
                            if (this.currentNoteIndex >= notes.length - 1) {
                                this.pendulumDirection = -1;
                                this.currentNoteIndex = notes.length - 1;
                            } else if (this.currentNoteIndex <= 0) {
                                this.pendulumDirection = 1;
                                this.currentNoteIndex = 0;
                            }
                            break;
                    }

                    if (note) {
                        const id = `gen_${Date.now()}`;
                        this.activeNote = { id, note };
                        this.onNoteOn(id, note.frequency, 0.7);
                    }
                }

                setBPM(bpm) {
                    this.bpm = bpm;
                }

                setProbability(prob) {
                    this.probability = prob;
                }

                setOctaveRange(low, high) {
                    this.octaveLow = low;
                    this.octaveHigh = high;
                    this.currentNoteIndex = 0;
                }

                setNoteLength(beats) {
                    this.noteLength = beats;
                }

                setPattern(pattern) {
                    this.pattern = pattern;
                    this.currentNoteIndex = 0;
                    this.pendulumDirection = 1;
                }
            }

            // ============================================================
            // MORPH MODULATOR (LFO, S&H, MIDI)
            // ============================================================
            class MorphModulator {
                constructor(onMorphChange) {
                    this.onMorphChange = onMorphChange;
                    this.mode = "manual"; // manual, lfo, snh, drift, midi-wheel, midi-velocity
                    this.rate = 1; // Hz
                    this.range = 1; // 0-1, how much of the terrain to sweep
                    this.offset = 0; // 0-1, starting point of modulation
                    this.animationId = null;
                    this.lastTime = 0;
                    this.phase = 0;
                    this.snhValue = 0.5;
                    this.snhLastTick = 0;
                    // Drift mode: smoothly interpolate between random targets
                    this.driftValue = 0.5;
                    this.driftTarget = 0.5;
                    this.driftLastTick = 0;
                    this.midiWheelValue = 0.5;
                    this.midiVelocityValue = 0.5;
                    this.baseValue = 0.5; // manual slider value
                }

                setMode(mode) {
                    this.mode = mode;
                    if (
                        mode === "manual" ||
                        mode === "midi-wheel" ||
                        mode === "midi-velocity"
                    ) {
                        this.stop();
                    } else {
                        this.start();
                    }
                }

                start() {
                    if (this.animationId) return;
                    this.lastTime = performance.now();
                    this.tick();
                }

                stop() {
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                        this.animationId = null;
                    }
                }

                tick() {
                    const now = performance.now();
                    const deltaTime = (now - this.lastTime) / 1000;
                    this.lastTime = now;

                    let newValue = this.baseValue;

                    if (this.mode === "lfo") {
                        // LFO: smooth sine wave
                        this.phase += deltaTime * this.rate * Math.PI * 2;
                        if (this.phase > Math.PI * 2) this.phase -= Math.PI * 2;
                        const rawValue = (Math.sin(this.phase) + 1) / 2; // 0-1 range
                        newValue = this.applyRangeOffset(rawValue);
                        this.onMorphChange(newValue);
                    } else if (this.mode === "snh") {
                        // S&H: random value at rate intervals
                        this.snhLastTick += deltaTime;
                        const interval = 1 / this.rate;
                        if (this.snhLastTick >= interval) {
                            this.snhLastTick = 0;
                            this.snhValue = Math.random();
                        }
                        newValue = this.applyRangeOffset(this.snhValue);
                        this.onMorphChange(newValue);
                    } else if (this.mode === "drift") {
                        // Drift: smoothly interpolate toward random targets
                        this.driftLastTick += deltaTime;
                        const interval = 1 / this.rate;
                        if (this.driftLastTick >= interval) {
                            this.driftLastTick = 0;
                            this.driftTarget = Math.random();
                        }
                        // Smooth interpolation toward target
                        const smoothing =
                            1 - Math.exp(-deltaTime * this.rate * 3);
                        this.driftValue +=
                            (this.driftTarget - this.driftValue) * smoothing;
                        newValue = this.applyRangeOffset(this.driftValue);
                        this.onMorphChange(newValue);
                    }

                    this.animationId = requestAnimationFrame(() => this.tick());
                }

                setRate(hz) {
                    this.rate = Math.max(0.1, hz);
                }

                setRange(range) {
                    this.range = Math.max(0.01, Math.min(1, range));
                }

                setOffset(offset) {
                    this.offset = Math.max(0, Math.min(1, offset));
                }

                // Apply range and offset to a 0-1 modulation value
                applyRangeOffset(rawValue) {
                    // rawValue is 0-1, scale it to range and shift by offset
                    // Clamp result to 0-1
                    const scaled = this.offset + rawValue * this.range;
                    return Math.max(0, Math.min(1, scaled));
                }

                setBaseValue(value) {
                    this.baseValue = value;
                    if (this.mode === "manual") {
                        this.onMorphChange(value);
                    }
                }

                // Called by MIDI controller
                setMidiWheel(value) {
                    this.midiWheelValue = value;
                    if (this.mode === "midi-wheel") {
                        const scaled = this.applyRangeOffset(value);
                        this.onMorphChange(scaled);
                    }
                }

                // Called when a note is played with velocity
                setMidiVelocity(velocity) {
                    this.midiVelocityValue = velocity;
                    if (this.mode === "midi-velocity") {
                        const scaled = this.applyRangeOffset(velocity);
                        this.onMorphChange(scaled);
                    }
                }

                getMode() {
                    return this.mode;
                }
            }

            // ============================================================
            // APPLICATION
            // ============================================================
            class App {
                constructor() {
                    this.terrain = new TerrainService();
                    this.search = new SearchService();
                    this.audio = new AudioEngine();
                    this.scaleManager = new ScaleManager();
                    this.midi = null;
                    this.waveformDisplay = null;
                    this.terrain3D = null;
                    this.map = null;
                    this.keyboard = null;
                    this.sequencer = null;
                    this.morphModulator = null;

                    this.currentLocation = null;
                    this.wavetableData = null;
                    this.isLightMode = false;
                    this.isLoading = false;
                }

                async initialize() {
                    // Initialize 3D terrain display
                    this.terrain3D = new Terrain3DDisplay(
                        document.getElementById("terrain-canvas"),
                    );

                    // Initialize waveform display
                    this.waveformDisplay = new WaveformDisplay(
                        document.getElementById("waveform-canvas"),
                    );

                    // Initialize map
                    this.map = new MapController("map", (lat, lng) =>
                        this.onMapClick(lat, lng),
                    );
                    this.map.initialize();

                    // Initialize keyboard
                    this.keyboard = new KeyboardInput(
                        (id, freq, vel) => this.noteOn(id, freq, vel),
                        (id) => this.noteOff(id),
                    );
                    this.keyboard.enable();

                    // Initialize MIDI
                    this.midi = new MidiController(
                        (note, freq, vel) =>
                            this.noteOn(`midi_${note}`, freq, vel),
                        (note) => this.noteOff(`midi_${note}`),
                        (cc, value) => this.onMidiCC(cc, value),
                    );
                    await this.midi.initialize();

                    // Initialize generative sequencer
                    this.sequencer = new GenerativeSequencer(
                        (id, freq, vel) => this.noteOn(id, freq, vel),
                        (id) => this.noteOff(id),
                    );
                    this.sequencer.setScaleManager(this.scaleManager);

                    // Initialize morph modulator
                    this.morphModulator = new MorphModulator((value) => {
                        this.setMorphPosition(value);
                        document.getElementById("morph-slider").value = value;
                        document.getElementById("morph-value").textContent =
                            value.toFixed(2);
                    });

                    // Bind UI controls
                    this.bindControls();

                    // Update keyboard with initial scale
                    this.updateKeyboard();

                    this.setStatus("Click map to load terrain");
                }

                bindControls() {
                    // Master volume
                    document
                        .getElementById("master-volume")
                        .addEventListener("input", (e) => {
                            this.audio.setMasterVolume(
                                parseFloat(e.target.value),
                            );
                        });

                    // Scale controls
                    document
                        .getElementById("root-note")
                        .addEventListener("change", (e) => {
                            this.scaleManager.setRoot(e.target.value);
                            this.updateKeyboard();
                        });
                    document
                        .getElementById("scale-type")
                        .addEventListener("change", (e) => {
                            this.scaleManager.setScale(e.target.value);
                            this.updateKeyboard();
                        });

                    // Morph slider
                    const morphSlider = document.getElementById("morph-slider");
                    const morphValue = document.getElementById("morph-value");
                    morphSlider.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        morphValue.textContent = value.toFixed(2);
                        this.morphModulator.setBaseValue(value);
                    });

                    // Morph modulation source selector
                    document
                        .getElementById("morph-mod-source")
                        .addEventListener("change", (e) => {
                            this.morphModulator.setMode(e.target.value);
                            // Show/hide rate slider based on mode
                            const rateSlider =
                                document.getElementById("morph-mod-rate");
                            const rateValue = document.getElementById(
                                "morph-mod-rate-value",
                            );
                            const showRate =
                                e.target.value === "lfo" ||
                                e.target.value === "snh" ||
                                e.target.value === "drift";
                            rateSlider.style.display = showRate ? "" : "none";
                            rateValue.style.display = showRate ? "" : "none";
                        });
                    document
                        .getElementById("morph-mod-rate")
                        .addEventListener("input", (e) => {
                            const value = parseFloat(e.target.value);
                            this.morphModulator.setRate(value);
                            document.getElementById(
                                "morph-mod-rate-value",
                            ).textContent = value.toFixed(1);
                        });

                    // Modulation range and offset
                    document
                        .getElementById("morph-mod-range")
                        .addEventListener("input", (e) => {
                            this.morphModulator.setRange(
                                parseFloat(e.target.value),
                            );
                        });
                    document
                        .getElementById("morph-mod-offset")
                        .addEventListener("input", (e) => {
                            this.morphModulator.setOffset(
                                parseFloat(e.target.value),
                            );
                        });

                    // Filter controls
                    const filterCutoff =
                        document.getElementById("filter-cutoff");
                    const filterCutoffValue = document.getElementById(
                        "filter-cutoff-value",
                    );
                    filterCutoff.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.audio.setFilterCutoff(value);
                        filterCutoffValue.textContent =
                            value >= 1000
                                ? `${(value / 1000).toFixed(1)}kHz`
                                : `${Math.round(value)}Hz`;
                    });

                    const filterResonance =
                        document.getElementById("filter-resonance");
                    const filterResonanceValue = document.getElementById(
                        "filter-resonance-value",
                    );
                    filterResonance.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.audio.setFilterResonance(value);
                        filterResonanceValue.textContent = value.toFixed(1);
                    });

                    // Reverb controls
                    const reverbMix = document.getElementById("reverb-mix");
                    const reverbMixValue =
                        document.getElementById("reverb-mix-value");
                    reverbMix.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.audio.setReverbMix(value);
                        reverbMixValue.textContent = `${Math.round(value * 100)}%`;
                    });

                    const reverbDecay = document.getElementById("reverb-decay");
                    const reverbDecayValue =
                        document.getElementById("reverb-decay-value");
                    reverbDecay.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.audio.setReverbDecay(value);
                        reverbDecayValue.textContent = `${value.toFixed(1)}s`;
                    });

                    // Generative controls
                    document
                        .getElementById("gen-play-btn")
                        .addEventListener("click", () => {
                            const btn = document.getElementById("gen-play-btn");
                            const icon =
                                document.getElementById("gen-play-icon");
                            if (btn.classList.contains("playing")) {
                                // Stop
                                btn.classList.remove("playing");
                                icon.innerHTML =
                                    '<polygon points="5,3 19,12 5,21"/>';
                                this.sequencer.stop();
                            } else {
                                // Play
                                this.audio.initialize().then(() => {
                                    btn.classList.add("playing");
                                    icon.innerHTML =
                                        '<rect x="5" y="3" width="4" height="18"/><rect x="15" y="3" width="4" height="18"/>';
                                    this.sequencer.start();
                                });
                            }
                        });

                    const genBpm = document.getElementById("gen-bpm");
                    const genBpmValue =
                        document.getElementById("gen-bpm-value");
                    genBpm.addEventListener("input", (e) => {
                        const value = parseInt(e.target.value);
                        this.sequencer.setBPM(value);
                        genBpmValue.textContent = value;
                    });

                    const genProbability =
                        document.getElementById("gen-probability");
                    const genProbabilityValue = document.getElementById(
                        "gen-probability-value",
                    );
                    genProbability.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.sequencer.setProbability(value);
                        genProbabilityValue.textContent = `${Math.round(value * 100)}%`;
                    });

                    document
                        .getElementById("gen-octave-low")
                        .addEventListener("change", (e) => {
                            const low = parseInt(e.target.value);
                            const high = parseInt(
                                document.getElementById("gen-octave-high")
                                    .value,
                            );
                            this.sequencer.setOctaveRange(
                                low,
                                Math.max(low, high),
                            );
                        });

                    document
                        .getElementById("gen-octave-high")
                        .addEventListener("change", (e) => {
                            const high = parseInt(e.target.value);
                            const low = parseInt(
                                document.getElementById("gen-octave-low").value,
                            );
                            this.sequencer.setOctaveRange(
                                Math.min(low, high),
                                high,
                            );
                        });

                    document
                        .getElementById("gen-length")
                        .addEventListener("change", (e) => {
                            this.sequencer.setNoteLength(
                                parseFloat(e.target.value),
                            );
                        });

                    document
                        .getElementById("gen-pattern")
                        .addEventListener("change", (e) => {
                            this.sequencer.setPattern(e.target.value);
                        });

                    // ADSR sliders
                    ["attack", "decay", "sustain", "release"].forEach(
                        (param) => {
                            const slider = document.getElementById(param);
                            const valueDisplay = document.getElementById(
                                `${param}-value`,
                            );

                            slider.addEventListener("input", (e) => {
                                const value = parseFloat(e.target.value);
                                const suffix = param === "sustain" ? "" : "s";
                                valueDisplay.textContent =
                                    value.toFixed(2) + suffix;
                                this.updateADSR();
                            });
                        },
                    );

                    // Theme toggle
                    document
                        .getElementById("theme-toggle")
                        .addEventListener("click", () => {
                            this.toggleTheme();
                        });

                    // Search
                    const searchInput = document.getElementById("search-input");
                    const searchBtn = document.getElementById("search-btn");

                    searchBtn.addEventListener("click", () =>
                        this.handleSearch(),
                    );
                    searchInput.addEventListener("keypress", (e) => {
                        if (e.key === "Enter") this.handleSearch();
                    });

                    // Reset view button
                    document
                        .getElementById("reset-view")
                        .addEventListener("click", () => {
                            this.terrain3D.resetView();
                        });

                    // My location button
                    document
                        .getElementById("location-btn")
                        .addEventListener("click", () => {
                            this.handleMyLocation();
                        });
                }

                updateKeyboard() {
                    const notes = this.scaleManager.getKeyboardNotes();
                    const keys = [
                        "a",
                        "s",
                        "d",
                        "f",
                        "g",
                        "h",
                        "j",
                        "k",
                        "l",
                        ";",
                        "'",
                    ];
                    const keyElements = document.querySelectorAll(".key");

                    keyElements.forEach((el, i) => {
                        if (i < notes.length) {
                            const note = notes[i];
                            el.dataset.freq = note.frequency;
                            el.dataset.note = note.note;
                            el.querySelector(".key-note").textContent =
                                note.note;
                            el.style.display = "";
                        } else {
                            // Hide keys that don't have notes in this scale
                            el.style.display = "none";
                        }
                    });

                    // Update keyboard input mapping
                    if (this.keyboard) {
                        this.keyboard.keyMap.clear();
                        keyElements.forEach((el, i) => {
                            if (i < notes.length) {
                                const key = keys[i];
                                this.keyboard.keyMap.set(key, {
                                    element: el,
                                    frequency: notes[i].frequency,
                                });
                            }
                        });
                    }
                }

                toggleTheme() {
                    this.isLightMode = !this.isLightMode;
                    document.body.classList.toggle(
                        "light-mode",
                        this.isLightMode,
                    );
                    document.getElementById("theme-toggle").textContent = this
                        .isLightMode
                        ? "Dark"
                        : "Light";

                    this.terrain3D.setLightMode(this.isLightMode);
                    this.waveformDisplay.setLightMode(this.isLightMode);
                }

                async handleSearch() {
                    const query = document
                        .getElementById("search-input")
                        .value.trim();
                    if (!query) return;

                    this.setStatus("Searching...", "loading");

                    try {
                        const result = await this.search.search(query);
                        this.setStatus(`Found: ${result.name}`);
                        this.map.goTo(result.lat, result.lng);
                    } catch (error) {
                        this.setStatus(
                            "Search failed: " + error.message,
                            "error",
                        );
                    }
                }

                handleMyLocation() {
                    if (!navigator.geolocation) {
                        this.setStatus("Geolocation not supported", "error");
                        return;
                    }

                    const btn = document.getElementById("location-btn");
                    btn.classList.add("locating");
                    this.setStatus("Finding your location...", "loading");

                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            btn.classList.remove("locating");
                            const { latitude, longitude } = position.coords;
                            this.setStatus(`Found: Your location`);
                            this.map.goTo(latitude, longitude, 12);
                        },
                        (error) => {
                            btn.classList.remove("locating");
                            let message = "Location error";
                            switch (error.code) {
                                case error.PERMISSION_DENIED:
                                    message = "Location permission denied";
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    message = "Location unavailable";
                                    break;
                                case error.TIMEOUT:
                                    message = "Location request timed out";
                                    break;
                            }
                            this.setStatus(message, "error");
                        },
                        { enableHighAccuracy: true, timeout: 10000 },
                    );
                }

                updateADSR() {
                    this.audio.setADSR(
                        parseFloat(document.getElementById("attack").value),
                        parseFloat(document.getElementById("decay").value),
                        parseFloat(document.getElementById("sustain").value),
                        parseFloat(document.getElementById("release").value),
                    );
                }

                async onMapClick(lat, lng) {
                    // Prevent double-loading
                    if (this.isLoading) {
                        console.log("Already loading, ignoring click");
                        return;
                    }

                    // Initialize audio on first interaction
                    await this.audio.initialize();

                    this.currentLocation = { lat, lng };
                    document.getElementById("location-display").textContent =
                        `${lat.toFixed(4)}, ${lng.toFixed(4)}`;

                    // Show loading
                    this.isLoading = true;
                    document
                        .getElementById("map-loading")
                        .classList.remove("hidden");

                    try {
                        // Fetch terrain
                        console.log(`Fetching terrain for ${lat}, ${lng}...`);
                        this.wavetableData = await this.terrain.fetchElevation(
                            lat,
                            lng,
                        );
                        console.log(
                            "Terrain data received:",
                            this.wavetableData,
                        );

                        // Load into audio engine
                        this.audio.loadWavetable(this.wavetableData.frames);

                        // Update visualizations
                        console.log("Updating visualizations...");
                        this.waveformDisplay.setFrames(
                            this.wavetableData.frames,
                        );
                        this.terrain3D.setFrames(this.wavetableData.frames);

                        // Update status
                        const { globalMin, globalMax } =
                            this.wavetableData.metadata;
                        this.setStatus(
                            `Terrain loaded: ${Math.round(globalMin)}m - ${Math.round(globalMax)}m`,
                        );
                    } catch (error) {
                        console.error("Failed to load terrain:", error);
                        this.setStatus(
                            "Failed to load terrain: " + error.message,
                            "error",
                        );
                    } finally {
                        this.isLoading = false;
                        document
                            .getElementById("map-loading")
                            .classList.add("hidden");
                    }
                }

                noteOn(noteId, frequency, velocity) {
                    // Update morph modulator with velocity
                    this.morphModulator.setMidiVelocity(velocity);
                    // Update slider display if in velocity mode
                    if (this.morphModulator.getMode() === "midi-velocity") {
                        document.getElementById("morph-slider").value =
                            velocity;
                        document.getElementById("morph-value").textContent =
                            velocity.toFixed(2);
                    }
                    this.audio.noteOn(noteId, frequency, velocity);
                }

                noteOff(noteId) {
                    this.audio.noteOff(noteId);
                }

                setMorphPosition(position) {
                    this.audio.setMorphPosition(position);
                    this.waveformDisplay.setMorphPosition(position);
                    this.terrain3D.setMorphPosition(position);
                }

                onMidiCC(cc, value) {
                    // CC1 = Mod wheel
                    if (cc === 1) {
                        this.morphModulator.setMidiWheel(value);
                        // Update slider display if in midi-wheel mode
                        if (this.morphModulator.getMode() === "midi-wheel") {
                            document.getElementById("morph-slider").value =
                                value;
                            document.getElementById("morph-value").textContent =
                                value.toFixed(2);
                        }
                    }
                }

                setStatus(message, type = "info") {
                    document.getElementById("status-message").textContent =
                        message;
                }

                setMidiStatus(connected, deviceName) {
                    const indicator = document.getElementById("midi-indicator");
                    const status = document.getElementById("midi-status");

                    if (connected) {
                        indicator.classList.add("connected");
                        status.textContent = deviceName;
                    } else {
                        indicator.classList.remove("connected");
                        status.textContent = deviceName;
                    }
                }
            }

            // ============================================================
            // INITIALIZATION
            // ============================================================
            const app = new App();
            document.addEventListener("DOMContentLoaded", () =>
                app.initialize(),
            );
        </script>
    </body>
</html>
